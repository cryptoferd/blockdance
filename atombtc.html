<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bitcoin Block Atom — Treemap (mempool colors, fixed background)</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='8' fill='%2300c2ff'/%3E%3C/svg%3E">
<style>
  :root { --panel:rgba(10,14,18,0.92); --border:#1e2a33; --text:#d9ecff; --muted:#9cc6eb; }
  html,body{margin:0;height:100%;background:#000;color:var(--text);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  /* True background: a separate 2D canvas that never rotates */
  #bg2d{position:fixed;inset:0;z-index:0;display:block;pointer-events:none;background:#000}
  canvas.p5canvas{position:fixed;inset:0;z-index:1;display:block;touch-action:none}
  .hud{position:fixed;z-index:20;left:10px;top:10px;display:flex;gap:8px;align-items:center;background:var(--panel);
       border:1px solid var(--border);border-radius:12px;padding:8px 10px;backdrop-filter:blur(6px);font-size:12px}
  .hud input, .hud button{font:inherit;border-radius:8px;border:1px solid var(--border);background:#121820;color:var(--text);padding:6px 8px}
  .hud button{cursor:pointer}
  .panel{position:fixed;z-index:11;font-size:12px;color:var(--muted);padding:8px 10px;background:var(--panel);
         border:1px solid var(--border);border-radius:12px;max-width:min(480px,calc(100vw - 20px));backdrop-filter:blur(6px)}
  #legend{left:10px;top:70px}
  details#blockPanel{right:10px;bottom:10px}
  details#blockPanel>summary{list-style:none;cursor:pointer;padding:10px 12px;color:#d7ecff;font-weight:700;display:flex;justify-content:space-between;gap:8px}
  details#blockPanel[open]>summary{border-bottom:1px solid var(--border)}
  details#blockPanel summary::-webkit-details-marker{display:none}
  #blkBody{padding:10px 12px;color:#b7d2ea}
  #blkBody td{padding:4px 0;vertical-align:top}
  #blkBody td:first-child{color:#9cc9ee;width:36%}
  details#infoPanel{left:10px;bottom:10px}
  details#infoPanel>summary{list-style:none;cursor:pointer;padding:10px 12px;color:#d7ecff;font-weight:700;display:flex;gap:8px;align-items:center}
  details#infoPanel[open]>summary{border-bottom:1px solid var(--border)}
  details#infoPanel summary .badge{width:22px;height:22px;display:inline-grid;place-items:center;border-radius:999px;background:#1e2a33;color:#cfe4ff;border:1px solid #2b3a44;font-weight:800}
  #warn{position:fixed;left:10px;top:120px;color:#ffd26f;font-weight:600;display:none;z-index:12}
  #progress{position:fixed;left:10px;top:48px;z-index:21;color:#d7ecff;font-size:12px;background:var(--panel);border:1px solid var(--border);padding:6px 10px;border-radius:10px;display:none}
  .chip{display:inline-block;padding:2px 6px;border:1px solid #2b3a44;border-radius:8px;margin:2px;color:#d7ecff;font-size:11px}
</style>
</head>
<body>

<!-- True background canvas (2D, screen space) -->
<canvas id="bg2d"></canvas>

<!-- Loader HUD -->
<div class="hud" id="hud">
  <label>Height:</label>
  <input id="heightInput" type="number" min="1" placeholder="e.g. 170 or 840000" style="width:140px"/>
  <button id="loadBtn">Load</button>
  <button id="latestBtn">Latest</button>
</div>
<div id="progress">…</div>

<script src="https://unpkg.com/p5@1.9.2/lib/p5.min.js"></script>
<script>
/* ---------- utils ---------- */
const $=s=>document.querySelector(s);
const shortHash=h=>h?(String(h).slice(0,10)+'…'+String(h).slice(-8)):'n/a';
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const mod=(a,n)=>((a%n)+n)%n;
function XS32(seed){let x=seed>>>0||1;return()=>{x^=x<<13;x^=x>>>17;x^=x<<5;return (x>>>0)/0xFFFFFFFF;};}
function hslToRgb(h,s,l){let r,g,b;if(s===0){r=g=b=l;}else{const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];}
function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;const max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,l=(max+min)/2;if(max===min){h=s=0;}else{const d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return[h,s,l];}
const shiftHue=(rgb,deg)=>{const[h,s,l]=rgbToHsl(rgb[0],rgb[1],rgb[2]);let hh=(h+(deg/360))%1; if(hh<0)hh+=1; return hslToRgb(hh,s,l);}
const mixRGB=(a,b,t)=>[Math.round(a[0]*(1-t)+b[0]*t),Math.round(a[1]*(1-t)+b[1]*t),Math.round(a[2]*(1-t)+b[2]*t)];
const lastByte = (hex)=>{ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); if(c.length<2) return 0; return parseInt(c.slice(-2),16)||0; };
const hexByteSum = (hex)=>{ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); let s=0; for(let i=0;i<c.length;i+=2){ const b=parseInt(c.substr(i,2),16); if(!isNaN(b)) s+=b; } return s; };
const byteAt=(hex,idx)=>{ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); if(c.length<2) return 0; const i=(idx*2)%(c.length-1); const b=parseInt(c.substr(i,2),16); return isNaN(b)?0:b; };
const approxLog2Target=bits=>{const exp=(bits>>>24)&0xff, mant=bits&0x007fffff||1; return Math.log2(mant)+8*(exp-3);};
const approxLog2Hash=hex=>{const c=(hex||'').replace(/[^0-9a-fA-F]/g,''); if(!c.length) return 0; let i=0; while(i<c.length && c[i]==='0') i++; const lead=parseInt(c.substr(i,2)||'01',16)||1; const bitsFromPos=(c.length-i)/2*8; return Math.log2(lead)+bitsFromPos-8;};
const isHalving=h=>h>0&&(h%210000)===0;

/* vec helpers */
const v3=(x,y,z)=>[x,y,z], vadd=(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]];
const vmul=(a,s)=>[a[0]*s,a[1]*s,a[2]*s], vdot=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
const vcross=(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
const vlen=a=>Math.hypot(a[0],a[1],a[2]); const vnorm=a=>{const l=vlen(a)||1; return [a[0]/l,a[1]/l,a[2]/l];};
function rotateAroundAxis(p,u,ang){const c=Math.cos(ang),s=Math.sin(ang),dot=vdot(u,p),cross=vcross(u,p);return vadd(vadd(vmul(p,c),vmul(cross,s)),vmul(u,(1-c)*dot));}

/* ---------- shader ---------- */
const VERT=`precision mediump float;attribute vec3 aPosition;uniform mat4 uModelViewMatrix,uProjectionMatrix;varying vec3 vObjPos;void main(){vObjPos=aPosition;gl_Position=uProjectionMatrix*(uModelViewMatrix*vec4(aPosition,1.0));}`;
const FRAG=`precision mediump float;varying vec3 vObjPos;uniform vec3 uColorA,uColorB;uniform float uMarbleInt,uMarbleScale,uTime,uAnimAmp,uAnimSpeed,uBlockPhase;
float h(vec3 p){return fract(sin(dot(p,vec3(12.9898,78.233,37.719)))*43758.5453);}
float n3(vec3 p){vec3 i=floor(p),f=fract(p);float n000=h(i+vec3(0,0,0)),n100=h(i+vec3(1,0,0));float n010=h(i+vec3(0,1,0)),n110=h(i+vec3(1,1,0));float n001=h(i+vec3(0,0,1)),n101=h(i+vec3(1,0,1));float n011=h(i+vec3(0,1,1)),n111=h(i+vec3(1,1,1));
vec3 u=f*f*(3.0-2.0*f);float n00=mix(n000,n100,u.x),n10=mix(n010,n110,u.x);float n01=mix(n001,n101,u.x),n11=mix(n011,n111,u.x);float n0=mix(n00,n10,u.y),n1=mix(n01,n11,u.y);return mix(n0,n1,u.z);}
float stripe2D(vec2 uv,float ph,float f){float zm=1.0+uAnimAmp*0.35*sin(uTime*(0.7+uAnimSpeed)+ph+uBlockPhase);uv*=zm;vec2 w1=vec2(n3(vec3(uv*0.8*f,uTime*0.35+ph+uBlockPhase)),n3(vec3(uv*1.1*f+3.17,uTime*0.28+ph+1.7+uBlockPhase)));
uv+=(w1-0.5)*(0.35+0.45*uAnimAmp);float s=sin((uv.x*6.2831*f*0.85)+(uv.y*6.2831*f*0.45)+3.2*w1.x+(uTime*(0.55+0.6*uAnimSpeed))+ph+uBlockPhase);return 0.5+0.5*s;}
float blinn(vec3 n,vec3 l,vec3 v,float sh){vec3 hh=normalize(l+v);return pow(max(dot(n,hh),0.0),sh);}
void main(){vec3 p=vObjPos;float r=length(p.xy);float sw=uAnimAmp*(0.5+0.5*sin(uTime*(0.6+uAnimSpeed)+uBlockPhase));float a=sw*r*1.8;float ca=cos(a),sa=sin(a);p.xz=mat2(ca,-sa,sa,ca)*p.xz;
vec3 n=normalize(p);vec3 w=pow(abs(n),vec3(6.0));w/=max(w.x+w.y+w.z,1e-4);float f=uMarbleScale;float sx=stripe2D(p.yz,0.0,f),sy=stripe2D(p.zx,2.1,f),sz=stripe2D(p.xy,4.2,f);
float t=pow(smoothstep(0.10,0.90,sx*w.x+sy*w.y+sz*w.z),0.85);vec3 tint=mix(uColorA,uColorB,t);float roughK=clamp((uMarbleScale-0.8)/5.2,0.0,1.0);float freq=mix(40.0,140.0,roughK);
float gx=stripe2D(p.yz,1.7,freq),gy=stripe2D(p.zx,3.8,freq),gz=stripe2D(p.xy,5.9,freq);vec3 base=tint*(0.83+0.17*(gx*w.x+gy*w.y+gz*w.z));
vec3 L1=normalize(vec3(0.6,0.7,0.5)),L2=normalize(vec3(-0.4,0.65,-0.2)),V=normalize(vec3(0.0,0.0,1.0));float ndl1=max(dot(n,L1),0.0),ndl2=max(dot(n,L2),0.0);
float rough=mix(0.55,0.12,roughK),shin=mix(36.0,200.0,1.0-rough);float m=clamp(uMarbleInt,0.0,1.0),mC=min(m,0.92);vec3 F0=mix(vec3(0.06),tint,mC);float VoH=max(dot(n,V),0.0);
vec3 F=F0+(1.0-F0)*pow(1.0-VoH,5.0);float spec=(blinn(n,L1,V,shin)*0.95+blinn(n,L2,V,shin)*0.75)*(0.95-0.5*rough);vec3 diff=base*max(0.12,mix(0.65,0.18,mC)*(0.35+(0.55*ndl1+0.45*ndl2)));
float rim=pow(1.0-max(dot(n,V),0.0),2.2)*0.12;vec3 col=pow(diff+F*spec+tint*rim,vec3(0.96));gl_FragColor=vec4(clamp(col,0.0,1.0),1.0);} `;

/* ---------- mapping ---------- */
const NUCLEUS_R0=28, SHELL_STEP=22, ELECTRON_R=3.6, NUCLEON_R=2.7;

function paletteFromHeight(height){
  const rng = XS32(height), golden = 137.50776405003785;
  let baseHue = mod((height * golden) + rng() * 45, 360);
  let hP = baseHue;
  let hN = mod(hP + (90 + rng() * 120), 360);
  let hE = mod(hP + (180 + rng() * 120), 360);
  let hS = mod(hP + (30 + rng() * 120), 360);
  let sP = 0.82 + 0.18 * rng(), lP = 0.48 + 0.12 * rng();
  let sN = 0.72 + 0.25 * rng(), lN = 0.52 + 0.12 * rng();
  let sE = 0.92 + 0.08 * rng(), lE = 0.58 + 0.12 * rng();
  let sS = 0.82 + 0.18 * rng(), lS = 0.56 + 0.12 * rng();
  return{
    proton:  hslToRgb(hP/360, sP, lP),
    neutron: hslToRgb(hN/360, sN, lN),
    electron:hslToRgb(hE/360, sE, lE),
    shell:   hslToRgb(hS/360, sS, lS)
  };
}
function feeSpread(){ return 0.25; }
function fillShells(e){ let shells=[],rem=e,n=1; while(rem>0&&shells.length<8){ const cap=2*n*n; const take=Math.min(rem,cap); shells.push(take); rem-=take; n++; } if(rem>0) shells.push(rem); return shells; }

/* ---------- mempool.space treemap colors (fee-rate bands) ----------
   Based on Nodeyez defaults "based on mempool.space" (histogramSatLevels):
   0–2:#d81b60, 2–3:#8e24aa, 3–4:#5e35b1, 4–5:#3949ab, 5–6:#1e88e5,
   6–8:#039be5, 8–10:#00acc1, 10–12:#00897b, 12–15:#43a047, 15–20:#7cb342,
   20–30:#c0ca33, 30–40:#fdd835, 40–50:#ffb300, 50–60:#fb8c00, 60–70:#f4511e,
   70–80:#6d4c41, 80–90:#757575, 90–100:#546e7a, 100–125:#b71c1c,
   125–150:#880e4f, 150+:#4a148c  */
const FEE_BANDS = [
  {min:0,   max:2,   col:"#d81b60"},
  {min:2,   max:3,   col:"#8e24aa"},
  {min:3,   max:4,   col:"#5e35b1"},
  {min:4,   max:5,   col:"#3949ab"},
  {min:5,   max:6,   col:"#1e88e5"},
  {min:6,   max:8,   col:"#039be5"},
  {min:8,   max:10,  col:"#00acc1"},
  {min:10,  max:12,  col:"#00897b"},
  {min:12,  max:15,  col:"#43a047"},
  {min:15,  max:20,  col:"#7cb342"},
  {min:20,  max:30,  col:"#c0ca33"},
  {min:30,  max:40,  col:"#fdd835"},
  {min:40,  max:50,  col:"#ffb300"},
  {min:50,  max:60,  col:"#fb8c00"},
  {min:60,  max:70,  col:"#f4511e"},
  {min:70,  max:80,  col:"#6d4c41"},
  {min:80,  max:90,  col:"#757575"},
  {min:90,  max:100, col:"#546e7a"},
  {min:100, max:125, col:"#b71c1c"},
  {min:125, max:150, col:"#880e4f"},
  {min:150, max:1e9, col:"#4a148c"},
];
const hex2rgb = hex => [parseInt(hex.slice(1,3),16),parseInt(hex.slice(3,5),16),parseInt(hex.slice(5,7),16)];
function feeColor(frate){
  for(const b of FEE_BANDS){ if(frate>=b.min && frate<b.max) return hex2rgb(b.col); }
  return hex2rgb("#4a148c");
}

/* ---------- Treemap background (true 2D screen layer) ---------- */
const bgCanvas = document.getElementById('bg2d');
const bgCtx    = bgCanvas.getContext('2d');
let bgBaseCanvas = document.createElement('canvas'); // offscreen base (static)
let bgBaseCtx    = bgBaseCanvas.getContext('2d', {alpha:false});
let bgTxs = []; // cached txs used by last render
function resizeBG(){
  const dpr = Math.max(1, window.devicePixelRatio||1);
  const w = Math.floor(window.innerWidth);
  const h = Math.floor(window.innerHeight);
  for(const c of [bgCanvas,bgBaseCanvas]){
    c.width = Math.floor(w*dpr);
    c.height= Math.floor(h*dpr);
    c.style.width = w+'px';
    c.style.height= h+'px';
    const ctx = (c===bgCanvas?bgCtx:bgBaseCtx);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  if(bgTxs.length){ renderTreemapBase(bgTxs); }
}
window.addEventListener('resize', resizeBG);

function squarifyTreemap(items, x, y, w, h, out){
  if(!items.length){ return; }
  if(items.length===1){ out.push({x,y,w,h,item:items[0]}); return; }
  const horizontal = w >= h;
  const total = items.reduce((s,it)=>s+it.w,0);
  let acc=0, bestIdx=0, bestWorst=Infinity;
  for(let i=0;i<items.length;i++){
    acc += items[i].w;
    const ratio = horizontal ? Math.max((acc/total)/(h/w), ((total-acc)/total)/(h/w))
                             : Math.max((acc/total)/(w/h), ((total-acc)/total)/(w/h));
    if(ratio<bestWorst){ bestWorst=ratio; bestIdx=i; }
  }
  const groupA = items.slice(0,bestIdx+1);
  const groupB = items.slice(bestIdx+1);
  const sumA = groupA.reduce((s,it)=>s+it.w,0), sumB = total - sumA;
  if(horizontal){
    const wA = Math.max(1, Math.round(w*sumA/total));
    squarifyTreemap(groupA, x, y, wA, h, out);
    squarifyTreemap(groupB, x+wA, y, w-wA, h, out);
  }else{
    const hA = Math.max(1, Math.round(h*sumA/total));
    squarifyTreemap(groupA, x, y, w, hA, out);
    squarifyTreemap(groupB, x, y+hA, w, h-hA, out);
  }
}

function renderTreemapBase(txs){
  bgTxs = txs||[];
  const w = Math.floor(bgBaseCanvas.width / (window.devicePixelRatio||1));
  const h = Math.floor(bgBaseCanvas.height / (window.devicePixelRatio||1));
  bgBaseCtx.setTransform(window.devicePixelRatio||1,0,0,window.devicePixelRatio||1,0,0);
  bgBaseCtx.fillStyle = "#000"; bgBaseCtx.fillRect(0,0,w,h);

  if(!txs || !txs.length){ return; }
  const items = [];
  for(const tx of txs){
    const vs = Math.max(1, tx.vsize || tx.size || 1);
    const fr = (tx.fee && vs) ? (tx.fee / vs) : 0;
    const [r,g,b] = feeColor(fr);
    // tiny variation per tx for texture (but keep band color recognizable)
    const jitter = ((parseInt((tx.txid||"").slice(-2),16)||0)%14) - 7;
    items.push({ w: vs, col:[clamp(r+jitter,0,255), clamp(g+jitter,0,255), clamp(b+jitter,0,255)] });
  }
  items.sort((a,b)=>b.w-a.w);
  const MAX = 1400; // perf cap
  const sliced = items.slice(0,MAX);
  const rects = [];
  squarifyTreemap(sliced, 0, 0, w, h, rects);

  bgBaseCtx.save();
  bgBaseCtx.translate(0.5,0.5); // crisp strokes
  for(const r of rects){
    bgBaseCtx.fillStyle = `rgb(${r.item.col[0]},${r.item.col[1]},${r.item.col[2]})`;
    bgBaseCtx.fillRect(r.x, r.y, r.w, r.h);
    // subtle border
    bgBaseCtx.strokeStyle = "rgba(255,255,255,0.08)";
    bgBaseCtx.strokeRect(r.x, r.y, Math.max(0,r.w-1), Math.max(0,r.h-1));
  }
  bgBaseCtx.restore();
}

// Draw one background animation frame (called from p5 draw)
function drawBackgroundFrame({halving}, t){
  const w = Math.floor(bgCanvas.width / (window.devicePixelRatio||1));
  const h = Math.floor(bgCanvas.height / (window.devicePixelRatio||1));
  bgCtx.setTransform(window.devicePixelRatio||1,0,0,window.devicePixelRatio||1,0,0);
  // copy static treemap
  bgCtx.clearRect(0,0,w,h);
  bgCtx.drawImage(bgBaseCanvas, 0, 0);
  // optional halving tint (subtle). To remove: comment this block.
  if(halving){
    const pulse = 0.5 + 0.5*Math.sin(t*2.2);
    bgCtx.fillStyle = `rgba(255,140,0,${0.20 + 0.25*pulse})`;
    bgCtx.fillRect(0,0,w,h);
  }
}

/* ---------- build atom from block ---------- */
const NUCLEON_R=2.7;
function buildAtomFromBlock(b){
  const height=b.height, txCount=b.tx_count??1, timestamp=b.timestamp??0;
  const bits=b.bits??0, nonce=b.nonce??0, merkleRoot=b.merkle_root||"", weight=b.weight??0, size=b.size??0, version=b.version??0, hash=b.id||b.hash||"";
  const colors=paletteFromHeight(height);

  const baseE=(height%118)+1, eJitter=(byteAt(hash,5)%64)-32;
  const electrons=clamp(baseE+eJitter, 6, 180);

  const protonBias=(byteAt(merkleRoot,9)%31)-15;
  const Z=clamp(baseE+protonBias, 6, 160);
  const neutronSkew=((byteAt(hash,2)%101)-50)/180;
  const N=clamp(Math.round(Z*(1.0+neutronSkew)) + (hexByteSum(merkleRoot)%17)-8, 6, 220);

  const shells=fillShells(electrons);

  const prod=Math.max(1, txCount*Math.max(1,size));
  const lg=Math.log10(prod);
  const speedScale=clamp((lg-8.6)/(10.7-8.6)*(2.2-0.55)+0.55, 0.55, 2.2);

  const dens=clamp(weight/Math.max(1,size*4),0.6,1.4);
  const fSpread=feeSpread();
  const tightness=clamp((dens*0.75)+(1.15-0.55*fSpread), 0.6,1.4);
  const eccGlobal=clamp(0.08+0.7*fSpread+((version&0xF)/60)+((nonce&0x3f)/255)*0.2, 0.08,0.88);

  const t2=approxLog2Target(bits), h2=approxLog2Hash(hash), luck=clamp((t2-h2)/24+1.0,0.7,1.5);
  const hashLast=lastByte(hash);
  const ringThickBase=0.8+(hashLast/255)*2.0;
  const ringThick=ringThickBase*(((version>>0)&1)?1.8:1.0);
  const ringAlpha=clamp(140+(luck-1.0)*120,80,255);
  const hueShiftDeg=(hashLast/255-0.5)*36;
  const ringColor=shiftHue(colors.shell, hueShiftDeg);

  const orbitSpread=1.0+((version&0xf)-7.5)*0.01;
  const radii=shells.map((_,i)=>(NUCLEUS_R0*1.3+SHELL_STEP*(i+1))*orbitSpread);

  // electrons meta
  const electronAngles=[], eMeta=[];
  for(let i=0;i<shells.length;i++){
    electronAngles[i]=[]; eMeta[i]=[];
    for(let j=0;j<shells[i];j++){
      const b0=byteAt(merkleRoot,(i*31+j*11+1)), b1=byteAt(hash,(i*17+j*7+5)), b2=byteAt(merkleRoot,(i*53+j*13+9));
      const seed=(b0<<16)^(b1<<8)^b2;
      let u=vnorm(v3((b0/255)-0.5,(b1/255)-0.5,(b2/255)-0.5)); if(vlen(u)<1e-6) u=[0,0,1];
      const ref=Math.abs(u[2])<0.9?[0,0,1]:[1,0,0]; let v=vnorm(vcross(u,ref)), w=vcross(u,v);
      const e=clamp(eccGlobal*(0.6+0.8*(b1/255)),0.05,0.93), pre=(0.05+0.45*(b2/255))*speedScale, phase=(b0/255)*Math.PI*2;
      const rosK=1+(seed%3), rosAmp=0.03+0.05*(b1/255), spMul=0.6+0.8*(b0/255);
      const hueOffset=( (i*97 + j*131 + seed) % 360 );
      electronAngles[i][j]=(b2/255)*Math.PI*2; eMeta[i][j]={u,v,w,e,pre,phase,rosK,rosAmp,spMul,hueOffset};
    }
  }

  const base=(timestamp%600)/600, noiseSeed=(nonce%997)/997;
  const speeds=shells.map((_,i)=> (0.004+0.015*((Math.sin((base+i*0.137+noiseSeed)*43758.5453)*0.5+0.5)))*speedScale);

  // nucleus points
  const totalNuc=Math.min(900,Z+N), nucleusPoints=[];
  for(let i=0;i<totalNuc;i++){
    const rNorm=Math.pow(Math.random(), tightness);
    const r=NUCLEUS_R0*(0.35+0.65*rNorm), th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
    const isProton = i<Z;
    const hueOffset = (i*23 + (isProton?177:311)) % 360;
    nucleusPoints.push({x:r*Math.sin(ph)*Math.cos(th),y:r*Math.sin(ph)*Math.sin(th),z:r*Math.cos(ph),isProton,hueOffset});
  }

  const mode=height%4; let MARBLE_INT=0.78, MARBLE_SCALE=3.6;
  if(mode===1){ MARBLE_INT=0.65; MARBLE_SCALE=4.4; }
  else if(mode===2){ MARBLE_INT=0.58; MARBLE_SCALE=2.6; }
  else if(mode===3){ MARBLE_INT=0.42; MARBLE_SCALE=2.0; }
  const animAmp=clamp(0.18+((version&0xF)/15)*0.12,0.18,0.45);
  const animSpeed=clamp(0.35+((nonce&0xFF)/255)*0.9,0.35,1.85);
  const blockPhase=(byteAt(merkleRoot,7)/255)*Math.PI*2;

  const isDisco = height===170;
  const halving = !isDisco && isHalving(height);

  return {
    block:b,height,Z,N,electrons,shells,radii,speeds,electronAngles,eMeta,nucleusPoints,colors,
    shader:{MARBLE_INT,MARBLE_SCALE,animAmp,animSpeed,blockPhase},
    style:{
      eSizeScale:clamp((((b.weight||b.size*4)-2.8e6)/(4.0e6-2.8e6))*(1.50-0.90)+0.90,0.7,1.8),
      ringThick:0.9, ringAlpha:220, ringColor:[180,150,255], nucleusTight:clamp((b.weight/Math.max(1,b.size*4))*0.75+(1.15-0.55*feeSpread()),0.6,1.4),
      halving, disco:isDisco
    }
  };
}

/* ---------- UI panels ---------- */
let uiPointerDown = false;

function injectPanels(atom){
  ['legend','blockPanel','infoPanel','warn'].forEach(id=>{const n=document.getElementById(id); if(n) n.remove();});

  // Legend
  const legend=document.createElement('div'); legend.id='legend'; legend.className='panel';
  legend.appendChild(document.createElement('div')).innerHTML='<b>Controls</b>';
  ['• Rotate/Tilt: drag','• Pan: right-drag / two-finger','• Zoom: wheel / pinch'].forEach(t=>{
    const d=document.createElement('div'); d.textContent=t; legend.appendChild(d);
  });
  document.body.appendChild(legend);

  // Block details
  const blk=atom.block;
  const det=document.createElement('details'); det.id='blockPanel'; det.className='panel';
  const sum=document.createElement('summary');
  const sLeft=document.createElement('span'); sLeft.textContent='▼ Block Details';
  const sRight=document.createElement('span'); sRight.style.color='#d7dfff'; sRight.style.fontWeight='500';
  sRight.textContent = '#' + blk.height + ' — ' + shortHash(blk.id||blk.hash);
  sum.appendChild(sLeft); sum.appendChild(sRight); det.appendChild(sum);

  const body=document.createElement('div'); body.id='blkBody';
  const chips=document.createElement('div'); chips.style.marginBottom='6px';
  [['Electrons',atom.electrons],['Protons',atom.Z],['Neutrons',atom.N]].forEach(([k,v])=>{
    const c=document.createElement('span'); c.className='chip'; c.textContent=`${k}: ${v}`; chips.appendChild(c);
  });
  if(atom.style.disco){ const c=document.createElement('span'); c.className='chip'; c.textContent='🎉 Disco 170'; chips.appendChild(c); }
  else if(atom.style.halving){ const c2=document.createElement('span'); c2.className='chip'; c2.textContent='Halving Mode'; chips.appendChild(c2); }
  body.appendChild(chips);

  const tbl=document.createElement('table');
  [['Tx count', blk.tx_count??'n/a'],
   ['Size (bytes)', blk.size??'n/a'],
   ['Weight (WU)', blk.weight??'n/a'],
   ['Version', blk.version??'n/a'],
   ['Bits', blk.bits??'n/a'],
   ['Nonce', blk.nonce??'n/a'],
   ['Time', (blk.timestamp? new Date(blk.timestamp*1000).toLocaleString():'n/a')],
   ['Merkle root', shortHash(blk.merkle_root)]].forEach(([k,v])=>{
      const tr=document.createElement('tr');
      const td1=document.createElement('td'); td1.textContent=k;
      const td2=document.createElement('td');
      if(k==='Merkle root'){ const code=document.createElement('code'); code.textContent=String(v); td2.appendChild(code); }
      else td2.textContent=String(v);
      tr.appendChild(td1); tr.appendChild(td2); tbl.appendChild(tr);
  });
  body.appendChild(tbl);
  det.appendChild(body);
  document.body.appendChild(det);

  // Info panel
  const info=document.createElement('details'); info.id='infoPanel'; info.className='panel';
  const infoSum=document.createElement('summary');
  const badge=document.createElement('span'); badge.className='badge'; badge.textContent='?';
  infoSum.appendChild(badge); infoSum.appendChild(document.createTextNode(' Info / How it works'));
  info.appendChild(infoSum);
  const infoBody=document.createElement('div'); infoBody.id='infoBody';
  infoBody.innerHTML = '<h3>Background treemap</h3><p>Each rectangle is a transaction; area ≈ vsize, color = mempool.space fee-rate band.</p><h3>Special cases</h3><p><b>Block 170</b>: rainbow disco. <b>Halving blocks</b>: gold nucleus, silver pulsing electrons; background keeps treemap with a subtle orange pulse overlay.</p>';
  info.appendChild(infoBody);
  document.body.appendChild(info);

  // UI guards
  const guard=n=>{n.addEventListener('pointerdown',()=>uiPointerDown=true);n.addEventListener('pointerup',()=>uiPointerDown=false);
                  n.addEventListener('pointerleave',()=>uiPointerDown=false);n.addEventListener('pointercancel',()=>uiPointerDown=false);
                  n.addEventListener('wheel',(e)=>{e.stopPropagation(); e.preventDefault();},{passive:false});};
  [legend,det,info].forEach(guard);

  const warn=document.createElement('div'); warn.id='warn'; warn.textContent='Shader fallback active (simplified lighting).'; document.body.appendChild(warn);
}

/* ---------- p5 sketch ---------- */
let p5Instance=null, orbShader=null, SHADER_OK=true;

function startSketch(blk, txsForBg){
  if(p5Instance){ p5Instance.remove(); p5Instance=null; }
  SHADER_OK=true;
  uiPointerDown=false;

  const atom=buildAtomFromBlock(blk);
  injectPanels(atom);

  // Build treemap base for this block on offscreen canvas, then show it every frame.
  const txs = (txsForBg||[]).map(t=>({txid:t.txid, vsize:t.vsize||t.size||1, size:t.size, fee:t.fee||0}));
  resizeBG(); renderTreemapBase(txs);

  const sketch=(p)=>{
    p.setup=function(){
      const cnv = p.createCanvas(p.windowWidth,p.windowHeight,p.WEBGL);
      cnv.canvas.classList.add('p5canvas');
      // IMPORTANT: alpha=true so WebGL canvas is transparent over the 2D bg
      p.setAttributes('alpha', true, 'antialias', true, 'premultipliedAlpha', false);
      orbShader=p.createShader(VERT,FRAG);
    };
    p.windowResized=()=>{ p.resizeCanvas(p.windowWidth,p.windowHeight); resizeBG(); renderTreemapBase(txs); };

    function drawOrbMat(cA,cB,r,t,metal,rough,amp,spd){
      p.noStroke();
      if(SHADER_OK){
        try{
          p.shader(orbShader);
          orbShader.setUniform('uColorA', cA.map(v=>v/255));
          orbShader.setUniform('uColorB', cB.map(v=>v/255));
          orbShader.setUniform('uMarbleInt', metal);
          orbShader.setUniform('uMarbleScale', rough);
          orbShader.setUniform('uTime', t);
          orbShader.setUniform('uAnimAmp', amp);
          orbShader.setUniform('uAnimSpeed', spd);
          orbShader.setUniform('uBlockPhase', atom.shader.blockPhase || 0.0);
          p.sphere(r);
          p.resetShader(); return;
        }catch(e){ SHADER_OK=false; $('#warn').style.display='block'; p.resetShader(); }
      }
      p.ambientMaterial(cA[0],cA[1],cA[2]); p.sphere(r);
    }
    const hueToRgb=h=>hslToRgb((h%360)/360, 0.95, 0.55);

    function drawRainbowRings(t){
      const steps = 180;
      const baseHue = (t*160) % 360;
      for(let i=0;i<atom.shells.length;i++){
        const r=atom.radii[i];
        p.push(); p.noFill(); p.strokeWeight(1.6);
        p.beginShape();
        for(let k=0;k<=steps;k++){
          const ang=(k/steps)*Math.PI*2;
          const hue = baseHue + (k/steps)*360 + i*18;
          const c=hueToRgb(hue);
          p.stroke(c[0],c[1],c[2],220);
          p.vertex(r*Math.cos(ang), r*Math.sin(ang), 0);
        }
        p.endShape();
        p.pop();
      }
    }
    function drawSoftHalo(radius, alpha, rings=24){
      p.push(); p.noFill();
      for(let i=0;i<rings;i++){
        const a = i*Math.PI*2/rings; p.rotateY(a);
        p.stroke(255,170,40, alpha * (1 - i/rings));
        p.strokeWeight(1);
        p.beginShape(); const steps=220;
        for(let k=0;k<=steps;k++){ const th=(k/steps)*Math.PI*2; p.vertex(radius*Math.cos(th), radius*Math.sin(th), 0); }
        p.endShape();
      }
      p.pop();
    }

    p.draw=function(){
      const t=p.millis()*0.001;
      const disco = atom.style.disco;
      const halving = atom.style.halving && !disco;

      // --- draw 2D background frame (never rotates) ---
      drawBackgroundFrame({halving}, t);

      // clear WebGL with transparency so bg shows through
      p.clear(0,0,0,0);
      const gl=p._renderer.GL; gl.clearDepth(1.0); gl.clear(gl.DEPTH_BUFFER_BIT);

      // controls + idle rotation
      const s = uiPointerDown?0:1; p.orbitControl(s,s,1.5);
      p.rotateY(t*0.06); p.rotateX(Math.sin(t*0.23)*0.05);

      // Rings
      if (disco){ drawRainbowRings(t); }
      else {
        for(let i=0;i<atom.shells.length;i++){
          const r=atom.radii[i];
          p.push(); p.noFill();
          if (halving){
            p.stroke(255,170,0,200);
            p.strokeWeight(1.6 + 0.8*Math.sin(t*2.0 + i));
          } else {
            p.stroke(atom.style.ringColor[0], atom.style.ringColor[1], atom.style.ringColor[2], atom.style.ringAlpha);
            p.strokeWeight(atom.style.ringThick);
          }
          p.beginShape(); const steps=160; for(let k=0;k<steps;k++){ const ang=(k/steps)*Math.PI*2; p.vertex(r*Math.cos(ang), r*Math.sin(ang), 0); }
          p.endShape(p.CLOSE); p.pop();
        }
      }

      // Nucleus
      p.push();
      for(const q of atom.nucleusPoints){
        p.push(); p.translate(q.x,q.y,q.z);
        if (disco){
          const hue = (t*220* (q.isProton?1.0:1.05) + q.hueOffset) % 360;
          const col = hueToRgb(hue);
          const pulse = 1.0 + 0.35*Math.sin(t*9.0 + q.hueOffset*0.05);
          drawOrbMat(col, col, NUCLEON_R*pulse, t, 0.7, 3.2, 0.25, 1.6);
        } else if (halving){
          const goldA=[255,215,64], goldB=[255,170,32];
          drawOrbMat(goldA, goldB, NUCLEON_R, t, 0.92, 3.4, 0.20, 0.65);
        } else if(q.isProton){
          drawOrbMat(atom.colors.proton, shiftHue(atom.colors.proton,18), NUCLEON_R, t, 0.85, 3.1, atom.shader.animAmp, atom.shader.animSpeed);
        } else {
          drawOrbMat(shiftHue(atom.colors.neutron,-22), atom.colors.neutron, NUCLEON_R, t, 0.30, 4.6, 0.12, 0.35);
        }
        p.pop();
      }
      p.pop();

      // Electrons
      for(let i=0;i<atom.shells.length;i++){
        const r=atom.radii[i], baseSpeed=atom.speeds[i];
        for(let j=0;j<atom.shells[i];j++){
          const m=atom.eMeta[i][j]; let th=atom.electronAngles[i][j];
          const a=r*(1+m.e*0.35), b=r*(1-m.e*0.35);
          const pre=t*m.pre + m.phase;
          const v=rotateAroundAxis(m.v,m.u,pre), w=rotateAroundAxis(m.w,m.u,pre);
          const basePt=vadd(vmul(v,a*Math.cos(th)), vmul(w,b*Math.sin(th)));
          const wob=1.0 + m.rosAmp*Math.sin(th*m.rosK + m.phase*0.7);
          const pt=vmul(basePt, wob);

          p.push(); p.translate(pt[0],pt[1],pt[2]);
          if (disco){
            const hue = (t*240 + m.hueOffset) % 360;
            const col = hueToRgb(hue);
            const pulse = 1.0 + 0.35*Math.sin(t*9.5 + m.hueOffset*0.07);
            drawOrbMat(col, col, ELECTRON_R*atom.style.eSizeScale*pulse, t, 0.65, 3.0, 0.3, 1.8);
          } else if (halving){
            const silverA=[220,228,235], silverB=[160,170,185];
            const pulse = 1.0 + 0.30*Math.sin(t*3.2 + i*0.7 + j*0.21);
            drawOrbMat(silverA, silverB, ELECTRON_R*atom.style.eSizeScale*pulse, t, 0.90, 3.0, 0.15, 0.9);
          } else {
            const mixT=((j%7)/7)*0.35; const eCol=mixRGB(atom.colors.electron, atom.style.ringColor, mixT);
            drawOrbMat(eCol, atom.style.ringColor, ELECTRON_R*atom.style.eSizeScale, t, atom.shader.MARBLE_INT, atom.shader.MARBLE_SCALE, atom.shader.animAmp, atom.shader.animSpeed);
          }
          p.pop();

          atom.electronAngles[i][j]+=baseSpeed*m.spMul;
        }
      }

      // Halving halo last (depth off so it overlays softly)
      if (halving){
        gl.disable(gl.DEPTH_TEST);
        const Rmax = atom.radii.length ? atom.radii[atom.radii.length-1] : 120;
        const haloR = Rmax + 26 + 6*Math.sin(t*2.0);
        drawSoftHalo(haloR, 42, 28);
        gl.enable(gl.DEPTH_TEST);
      }
    };
  };

  const container=document.createElement('div'); container.style.position='fixed'; container.style.inset='0'; container.style.zIndex='1';
  document.body.appendChild(container);
  p5Instance=new p5(sketch, container);
}

/* ---------- networking ---------- */
const API='https://mempool.space/api';
async function fetchText(u){const r=await fetch(u); if(!r.ok) throw new Error(r.status+' '+u); return (await r.text()).trim();}
async function fetchJSON(u){const r=await fetch(u); if(!r.ok) throw new Error(r.status+' '+u); return r.json();}

// page through txs: /block/{hash}/txs/0, /1, ...
async function fetchAllBlockTxs(hash, maxPages=400){
  const txs=[]; let page=0;
  while(page<maxPages){
    try{
      const arr = await fetchJSON(`${API}/block/${hash}/txs/${page}`);
      if(!arr || !arr.length) break;
      for(const t of arr){ txs.push({ txid:t.txid||t.hash, vsize:t.vsize||t.size, size:t.size, fee:t.fee }); }
      page++;
    }catch(e){ break; }
  }
  return txs;
}

async function loadBlockByHeight(height){
  $('#progress').style.display='block'; $('#progress').textContent='Resolving block '+height+'…';
  const hash=await fetchText(API+'/block-height/'+height);
  $('#progress').textContent='Fetching header…';
  const blk=await fetchJSON(API+'/block/'+hash);
  $('#progress').textContent='Fetching transactions…';
  const txs=await fetchAllBlockTxs(hash);
  $('#progress').style.display='none';
  startSketch(blk, txs);
}
async function loadLatest(){
  $('#progress').style.display='block'; $('#progress').textContent='Getting tip height…';
  const h=await fetchText(API+'/blocks/tip/height'); $('#heightInput').value=h;
  await loadBlockByHeight(h);
}

/* ---------- HUD + guards ---------- */
const hud=$('#hud');
['pointerdown','wheel'].forEach(ev=>hud.addEventListener(ev,()=>{uiPointerDown=true;},{passive:false}));
['pointerup','pointerleave','pointercancel'].forEach(ev=>hud.addEventListener(ev,()=>{uiPointerDown=false;}));

$('#loadBtn').onclick=async()=>{const h=Number($('#heightInput').value); if(!h){alert('Enter a block height'); return;}
  try{ await loadBlockByHeight(h);}catch(e){ $('#progress').textContent='Error: '+e.message; }};
$('#latestBtn').onclick=async()=>{ try{ await loadLatest(); }catch(e){ $('#progress').textContent='Error: '+e.message; }};

// // Optional: auto-load latest
// loadLatest();
</script>
</body>
</html>
