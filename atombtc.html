<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Bitcoin Block Atom — Seamless Metallic + Block-Driven Features</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.dom.min.js"></script>
<style>
  :root { --panel-bg: rgba(10,14,18,0.90); --panel-border:#1e2a33; --text:#cfe4ff; --muted:#8fbfe6; --accent:#9fd2ff; }
  html, body { margin:0; height:100%; background:#0b0f12; color:var(--text); font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; }
  canvas { display:block; }
  #ui { position: fixed; top:10px; left:10px; z-index:12; background:var(--panel-bg); border:1px solid var(--panel-border); border-radius:12px; padding:10px 12px; box-shadow:0 6px 20px rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
  #ui h1 { font-size:14px; margin:0 0 8px; color:var(--accent); font-weight:600; }
  #ui input { width:140px; background:#0e1419; border:1px solid #2b3a44; color:#e6f2ff; border-radius:8px; padding:6px 8px; }
  #ui button { background:#133a5a; color:#e6f2ff; border:1px solid #1f4f78; border-radius:8px; padding:6px 10px; cursor:pointer; }
  #ui button:hover { filter:brightness(1.15); }
  #meta { margin-top:8px; font-size:12px; line-height:1.35; color:#b7d2ea; max-width:380px; }
  .panel { position: fixed; z-index:11; font-size:12px; color:var(--muted); padding:8px 10px; background:var(--panel-bg); border:1px solid var(--panel-border); border-radius:12px; max-width:420px; }
  #legend { right:10px; top:10px; }
  #fx { right:10px; top:150px; min-width:270px; }
  #fx label { display:flex; gap:8px; align-items:center; margin:6px 0; }
  input[type="range"] { width:100%; }
  #blockPanel { position: fixed; right:10px; bottom:10px; z-index:11; width:min(420px, calc(100vw - 20px)); background:var(--panel-bg); border:1px solid var(--panel-border); border-radius:12px; overflow:hidden; }
  details#blockPanel > summary { list-style:none; cursor:pointer; padding:10px 12px; color:var(--accent); font-weight:600; display:flex; align-items:center; justify-content:space-between; }
  details#blockPanel[open] > summary { border-bottom:1px solid var(--panel-border); }
  details#blockPanel summary::-webkit-details-marker { display:none }
  #blkBody { padding:10px 12px; color:#b7d2ea; }
  #blkBody table { width:100%; border-collapse: collapse; }
  #blkBody td { padding:4px 0; vertical-align: top; }
  #blkBody td:first-child { color:#8fbfe6; width:34%; }
  .chip { display:inline-block; padding:2px 6px; border:1px solid #2b3a44; border-radius:8px; margin:2px 2px 2px 0; color:#d7ecff; font-size:11px; }
  #warn { color:#ffd26f; font-weight:600; display:none; margin-top:6px; }

  /* Info panel */
  details#infoPanel { left:10px; top:150px; width:min(480px, calc(100vw - 20px)); }
  details#infoPanel > summary { list-style:none; cursor:pointer; padding:10px 12px; color:#d7ecff; font-weight:700; display:flex; gap:8px; align-items:center; }
  details#infoPanel[open] > summary { border-bottom:1px solid var(--panel-border); }
  details#infoPanel summary .badge { width:22px; height:22px; display:inline-grid; place-items:center; border-radius:999px; background:#1e2a33; color:#cfe4ff; border:1px solid #2b3a44; font-weight:800; }
  #infoBody { padding:10px 12px; color:#b7d2ea; }
  #infoBody h3 { margin:8px 0 4px; color:#e3f1ff; font-size:13px; }
  #infoBody p { margin:6px 0; }
  #infoBody ul { margin:6px 0 6px 18px; }
  #infoBody code { background:#0e1419; border:1px solid #2b3a44; padding:1px 4px; border-radius:6px; color:#e8f4ff; }
  #infoBody table { width:100%; border-collapse:collapse; margin-top:6px; }
  #infoBody td { padding:4px 0; vertical-align:top; }
  #infoBody td:first-child { width:32%; color:#9cc9ee; }
</style>
</head>
<body>
  <div id="ui">
    <h1>Bitcoin Block → Atom</h1>
    <div style="display:flex; gap:6px; align-items:center; margin-bottom:6px; flex-wrap:wrap;">
      <label for="height">Height:</label>
      <input id="height" type="number" min="0" placeholder="e.g. 840000" />
      <button id="load">Load</button>
      <button id="latest">Latest</button>
    </div>
    <div id="meta"><b>Controls:</b> Rotate = drag · Zoom = scroll/pinch · Pan = right-drag / 3-finger (touch)</div>
    <div id="warn">Shader fallback active (colors OK, simplified)</div>
  </div>

  <div id="legend" class="panel">
    <div><b>Nucleus:</b> protons / neutrons</div>
    <div><b>Shells:</b> electrons (2n² capacity)</div>
    <div><b>Colors:</b> deterministic from block height</div>
  </div>

  <div id="fx" class="panel">
    <div style="font-weight:600;color:#cfe4ff;margin-bottom:6px;">Visual dials</div>
    <label>Mode from height <span id="modeName" style="color:#d7ecff;font-weight:600;">(auto)</span></label>
    <label>Marble intensity <span id="marbleIntVal">0.85</span>
      <input id="marbleInt" type="range" min="0" max="1" step="0.01" value="0.85"/>
    </label>
    <label>Marble scale <span id="marbleScaleVal">3.2</span>
      <input id="marbleScale" type="range" min="0.8" max="6.0" step="0.1" value="3.2"/>
    </label>
    <label><input id="fxRings" type="checkbox" checked /> Show shell rings</label>
  </div>

  <details id="blockPanel">
    <summary>
      <span>▼ Block Details</span>
      <span id="blkTitle" style="color:#d7dfff;font-weight:500;">(none loaded)</span>
    </summary>
    <div id="blkBody"><div style="margin-bottom:6px;">Load a block (height or Latest) to populate details.</div></div>
  </details>

  <!-- NEW: Info / Help collapsible -->
  <details id="infoPanel" class="panel" open>
    <summary><span class="badge">?</span> Info / Help</summary>
    <div id="infoBody">
      <h3>What this is</h3>
      <p>This renders a stylized atom where the “chemistry” is driven by a Bitcoin block. Colors come from <b>height</b>; motion, sizes, tilts and accents come from header fields (tx count, nonce, bits, etc.). The surface is a <b>seamless metallic</b> shader—no UV seams.</p>

      <h3>How to use</h3>
      <ul>
        <li><b>Load a block:</b> Enter a height and press <code>Load</code>, or hit <code>Latest</code>.</li>
        <li><b>Navigate 3D:</b> Drag = rotate · Scroll/Pinch = zoom · Right-drag (or 3-finger) = pan.</li>
        <li><b>Tune look:</b> The two sliders map to the metallic shader:
          <ul>
            <li><i>Marble intensity</i> = <b>Metalness</b> (0..1)</li>
            <li><i>Marble scale</i> = <b>Roughness grain</b> (higher → finer brush, sharper highlights)</li>
          </ul>
        </li>
        <li><b>Details:</b> Open the “Block Details” panel (bottom-right) to see the header fields used.</li>
      </ul>

      <h3>Block → Visual mapping</h3>
      <table>
        <tr><td><b>height</b></td><td>Global palette + effect mode (names shown next to “Mode”).</td></tr>
        <tr><td><b>tx_count</b></td><td>Electron orbit speeds (busier → faster), slight phase “raggedness”.</td></tr>
        <tr><td><b>weight / size</b></td><td>Electron size scale (heavier → larger).</td></tr>
        <tr><td><b>nonce</b></td><td>Shell tilt pattern + orbit eccentricity (subtle ellipses).</td></tr>
        <tr><td><b>version</b></td><td>Proton/Neutron color swap, ring thickness toggle.</td></tr>
        <tr><td><b>bits + hash</b></td><td>“Luck/energy” → speed multiplier, nucleus tightness, ring alpha/width.</td></tr>
        <tr><td><b>timestamp / mediantime</b></td><td>Gentle spin wobble & breathing scale.</td></tr>
        <tr><td><b>merkle_root</b></td><td>Per-electron phase, color bias, tilt jitter (high entropy → variety).</td></tr>
        <tr><td><b>hash (last byte)</b></td><td>Ring hue shift and base thickness.</td></tr>
      </table>

      <h3>Tips</h3>
      <ul>
        <li>On older devices, uncheck <b>Show shell rings</b> to reduce overdraw.</li>
        <li>If you see “Shader fallback” above, your browser disabled custom shaders; you’ll still get colored solids.</li>
        <li>Try different heights to sample very different palettes (height is hashed with a golden-angle hue walk).</li>
      </ul>
    </div>
  </details>

<script>
/* -------- Safe DOM helpers -------- */
function safeHTML(id, html){ const el=document.getElementById(id); if(el) el.innerHTML = html; }
function safeText(id, text){ const el=document.getElementById(id); if(el) el.textContent = text; }
function escapeHtml(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function setMeta(text){ safeHTML('meta', text); }

/* -------- Constants & State -------- */
const API = "https://mempool.space/api";

const NUCLEUS_BASE_R = 28;
const SHELL_R_STEP   = 22;
const ELECTRON_R     = 3.6;
const NUCLEON_R      = 2.7;

let MARBLE_INT = 0.85;   // used as metalness in metallic shader
let MARBLE_SCALE = 3.2;  // used as roughness control
let FX_RINGS = true;

let atom = null;
let orbShader;
let SHADER_OK = true;

let bgStars = [];
const BG_STAR_COUNT = 350;

/* -------- Seamless tri-planar metallic shader -------- */
const ORB_VERT = `
precision mediump float;
attribute vec3 aPosition;
uniform mat4 uModelViewMatrix, uProjectionMatrix;
varying vec3 vObjPos;
void main(){
  vObjPos = aPosition;
  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(aPosition,1.0));
}
`;

const ORB_FRAG = `
precision mediump float;
varying vec3 vObjPos;
uniform vec3  uColorA, uColorB;
uniform float uMarbleInt;   // metalness 0..1
uniform float uMarbleScale; // roughness control
uniform float uTime;

float h(vec3 p){ return fract(sin(dot(p, vec3(12.9898,78.233,37.719))) * 43758.5453); }
float n3(vec3 p){
  vec3 i=floor(p), f=fract(p);
  float n000=h(i+vec3(0,0,0)), n100=h(i+vec3(1,0,0));
  float n010=h(i+vec3(0,1,0)), n110=h(i+vec3(1,1,0));
  float n001=h(i+vec3(0,0,1)), n101=h(i+vec3(1,0,1));
  float n011=h(i+vec3(0,1,1)), n111=h(i+vec3(1,1,1));
  vec3 u=f*f*(3.0-2.0*f);
  float n00=mix(n000,n100,u.x), n10=mix(n010,n110,u.x);
  float n01=mix(n001,n101,u.x), n11=mix(n011,n111,u.x);
  float n0=mix(n00,n10,u.y), n1=mix(n01,n11,u.y);
  return mix(n0,n1,u.z);
}

float brush2D(vec2 uv, float freq){
  float w = n3(vec3(uv*0.8, uTime*0.1));
  float s = abs(sin(uv.x*freq + w*2.0));
  return s;
}

float blinnSpec(vec3 n, vec3 l, vec3 v, float shin){
  vec3 h = normalize(l+v);
  return pow(max(dot(n,h), 0.0), shin);
}

void main(){
  vec3 n = normalize(vObjPos);

  // tri-planar weights
  vec3 w = pow(abs(n), vec3(6.0));
  w /= max(w.x + w.y + w.z, 1e-4);

  vec3 baseTint = mix(uColorA, uColorB, 0.5);

  float roughK = clamp((uMarbleScale - 0.8) / 5.2, 0.0, 1.0);
  float freq = mix(40.0, 140.0, roughK);
  float gx = brush2D(vObjPos.yz, freq);
  float gy = brush2D(vObjPos.zx, freq);
  float gz = brush2D(vObjPos.xy, freq);
  float grain = (gx*w.x + gy*w.y + gz*w.z);
  vec3 base = baseTint * (0.85 + 0.15 * grain);

  vec3 L1 = normalize(vec3(0.6, 0.7, 0.5));
  vec3 L2 = normalize(vec3(-0.4, 0.65, -0.2));
  vec3 V  = normalize(vec3(0.0, 0.0, 1.0));

  float ndl1 = max(dot(n, L1), 0.0);
  float ndl2 = max(dot(n, L2), 0.0);

  float rough = mix(0.55, 0.12, roughK);
  float shin  = mix(28.0, 180.0, 1.0 - rough);

  float m = clamp(uMarbleInt, 0.0, 1.0);
  vec3  F0 = mix(vec3(0.04), baseTint, m);
  float VoH = max(dot(n, V), 0.0);
  vec3  F = F0 + (1.0 - F0) * pow(1.0 - VoH, 5.0);

  float spec1 = blinnSpec(n, L1, V, shin);
  float spec2 = blinnSpec(n, L2, V, shin);
  float specAmt = (spec1*0.9 + spec2*0.7) * (0.9 - 0.5*rough);

  vec3  specCol = F * specAmt;
  vec3  diffCol = base * (1.0 - m) * (0.10 + 0.75*ndl1 + 0.55*ndl2);

  vec3 color = diffCol + specCol;

  float rim = pow(1.0 - max(dot(n,V),0.0), 2.5) * 0.12;
  color += baseTint * rim;

  gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
}
`;

/* -------- Utilities -------- */
function XS32(seed){ let x=seed>>>0||1; return ()=>{ x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/0xFFFFFFFF; }; }
function mod(a,n){ return ((a%n)+n)%n; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function hslToRgb(h,s,l){
  let r,g,b;if(s===0){r=g=b=l;}else{
    const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};
    const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;
    r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3);
  }
  return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
}
function rgbToHsl(r, g, b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h, s, l=(max+min)/2;
  if(max===min){ h=s=0; }
  else{
    const d=max-min;
    s=l>0.5 ? d/(2-max-min) : d/(max+min);
    switch(max){
      case r: h=(g-b)/d+(g<b?6:0); break;
      case g: h=(b-r)/d+2; break;
      case b: h=(r-g)/d+4; break;
    }
    h/=6;
  }
  return [h,s,l];
}
function shiftHue(rgb, deg){
  const [h,s,l]=rgbToHsl(rgb[0],rgb[1],rgb[2]);
  let hh = (h + (deg/360)) % 1; if(hh<0) hh+=1;
  return hslToRgb(hh, s, l);
}
function mixRGB(a,b,t){ return [ Math.round(a[0]*(1-t)+b[0]*t), Math.round(a[1]*(1-t)+b[1]*t), Math.round(a[2]*(1-t)+b[2]*t) ]; }

function paletteFromHeightWide(height){
  const rng=XS32(height); const golden=137.50776405003785;
  let baseHue=mod((height*golden)+rng()*45,360);
  let hP=baseHue, hN=mod(baseHue+(90+rng()*120),360), hE=mod(baseHue+(180+rng()*120),360), hS=mod(baseHue+(30+rng()*120),360);
  let sP=0.80+0.15*rng(), lP=0.50+0.10*rng();
  let sN=0.70+0.25*rng(), lN=0.52+0.12*rng();
  let sE=0.90+0.10*rng(), lE=0.60+0.10*rng();
  let sS=0.80+0.15*rng(), lS=0.58+0.10*rng();
  return{ proton:hslToRgb(hP/360,sP,lP), neutron:hslToRgb(hN/360,sN,lN), electron:hslToRgb(hE/360,sE,lE), shell:hslToRgb(hS/360,sS,lS) };
}
function hexByteSum(hex){ if(!hex) return 0; hex=hex.replace(/[^0-9a-fA-F]/g,''); let s=0; for(let i=0;i<hex.length;i+=2){ let b=parseInt(hex.substr(i,2),16); if(!isNaN(b)) s+=b; } return s; }
function byteAt(hex,idx){ if(!hex) return 0; hex=hex.replace(/[^0-9a-fA-F]/g,''); if(hex.length<2) return 0; let i=(idx*2)%(hex.length-1); let b=parseInt(hex.substr(i,2),16); return isNaN(b)?0:b; }
function lastByte(hex){ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); if(c.length<2) return 0; return parseInt(c.slice(-2),16)||0; }
function fillShells(e){ let shells=[],rem=e,n=1; while(rem>0&&shells.length<8){ let cap=2*n*n; let take=Math.min(rem,cap); shells.push(take); rem-=take; n++; } if(rem>0) shells.push(rem); return shells; }
function fract(x){ return x-Math.floor(x); }
function sinHash(x){ return Math.sin(x*43758.5453123)*0.5+0.5; }
function shortHash(h){ return h ? (h.slice(0,10)+'…'+h.slice(-8)) : 'n/a'; }

/* --- Approx difficulty vs hash → luck (no BigInt needed) --- */
function approxLog2Target(bits){
  const exp = (bits >>> 24) & 0xff;
  const mant = bits & 0x007fffff || 1;
  return Math.log2(mant) + 8*(exp-3);
}
function approxLog2Hash(hashHex){
  const hex = (hashHex||'').replace(/[^0-9a-fA-F]/g,'');
  if(!hex.length) return 0;
  let i=0; while(i<hex.length && hex[i]==='0') i++;
  const byteStr = hex.substr(i,2) || '01';
  const lead = parseInt(byteStr,16) || 1;
  const bitsFromPos = (hex.length - i)/2 * 8;
  return Math.log2(lead) + bitsFromPos - 8;
}

/* -------- Block → Atom -------- */
function buildAtomFromBlock(block){
  const height     = block.height;
  const txCount    = block.tx_count || 1;
  const timestamp  = block.timestamp || 0;
  const mediantime = block.mediantime || timestamp;
  const bits       = block.bits || 0;
  const nonce      = block.nonce || 0;
  const merkleRoot = block.merkle_root || block.merkleRoot || "";
  const weight     = block.weight || 0;
  const size       = block.size || 0;
  const version    = block.version || 0;
  const hash       = block.id || block.hash || "";

  // --- Palette & base atomic numbers
  let colors = paletteFromHeightWide(height);
  const flipPN = ((version>>1)&1)===1; // version-driven skew
  if (flipPN) {
    const tmp = colors.proton; colors.proton = colors.neutron; colors.neutron = tmp;
  }

  const Z = (height % 118) + 1;                       // protons/electrons
  const N = (hexByteSum(merkleRoot) % 200);           // neutron approx
  const electrons = Z;
  const shells = fillShells(electrons);

  // --- Global “luck/energy”
  const t2 = approxLog2Target(bits);
  const h2 = approxLog2Hash(hash);
  const luck = clamp((t2 - h2)/24 + 1.0, 0.7, 1.5);

  // --- Speed scaling (tx_count) × luck
  const speedScale = clamp(map(txCount, 50, 6000, 0.9, 1.6), 0.7, 1.8) * luck;

  // --- Electron size (weight / size)
  const weightOrSize = weight || size*4;
  const eSizeScale = map(constrain(weightOrSize, 2.8e6, 4.0e6), 2.8e6, 4.0e6, 0.90, 1.50);

  // --- Nucleus tightness (bits, hash luck) and density (weight vs size)
  const dens = clamp((weight / Math.max(1, size*4)), 0.6, 1.4);
  const nonceNorm = (nonce >>> 0) / 4294967295;
  let nucleusScale = map(nonceNorm, 0, 1, 0.65, 1.10);
  nucleusScale *= dens;
  nucleusScale *= 1.0 / Math.sqrt(luck); // more lucky → tighter

  // --- Shell radii & spread (version & tx busyness)
  const spreadTx = map(constrain(txCount, 1, 6000), 1, 6000, 0.9, 1.35);
  const spreadVer = 1.0 + ((version & 0xF) - 7.5) * 0.01;
  const orbitSpread = spreadTx * spreadVer;
  const radii = shells.map((_, i) => (NUCLEUS_BASE_R*1.3 + SHELL_R_STEP*(i+1)) * orbitSpread);

  // --- Per-shell tilt from merkle_root; eccentricity from nonce
  const shellTilt = shells.map((_, s)=>{
    const b = byteAt(merkleRoot, s*3);
    return map(b, 0, 255, 0.05, 0.7); // radians
  });
  const eccA = [], eccB = [];
  for(let i=0;i<shells.length;i++){
    const rng = XS32(nonce ^ (i*0x9e3779b1));
    const ecc = rng(); // 0..1
    const aMul = 1.0 + 0.08*ecc;
    const bMul = 1.0 - 0.08*ecc;
    eccA.push(aMul); eccB.push(bMul);
  }

  // --- Electron angles + per-electron jitter & color bias (merkle)
  const jitterAmp = clamp(map(txCount, 50, 6000, 0.0, 0.45), 0.0, 0.5);
  const electronAngles=[], eColorMix=[], eTiltJitter=[];
  for(let i=0;i<shells.length;i++){
    electronAngles[i]=[]; eColorMix[i]=[]; eTiltJitter[i]=[];
    for(let j=0;j<shells[i];j++){
      const seedByte = byteAt(merkleRoot, (i*31+j)%Math.max(1,merkleRoot.length));
      let ang = (seedByte/255) * TWO_PI;
      const jit = ((byteAt(merkleRoot, i*97+j*11)/255)-0.5) * jitterAmp;
      ang += jit;
      electronAngles[i][j] = ang;

      eColorMix[i][j] = clamp((byteAt(merkleRoot, i*53+j*7)/255) * 0.25, 0.0, 0.25); // bias toward shell color
      eTiltJitter[i][j] = map(byteAt(merkleRoot, i*19 + j*5), 0, 255, -0.08, 0.08);
    }
  }

  // --- Nucleus cloud points
  const nucleusPoints=[];
  const nucleusCount = Math.min(900, Z + N);
  for(let i=0;i<nucleusCount;i++){
    const r = NUCLEUS_BASE_R * nucleusScale * (0.55 + Math.random()*0.45);
    const theta = Math.random()*TWO_PI;
    const phi = Math.acos(2*Math.random()-1);
    nucleusPoints.push({
      x: r*Math.sin(phi)*Math.cos(theta),
      y: r*Math.sin(phi)*Math.sin(theta),
      z: r*Math.cos(phi),
      isProton: i < Z
    });
  }

  // --- Rings: thickness/alpha from hash + luck, color small hue shift
  const hashLast = lastByte(hash);
  const ringThickBase = 0.8 + (hashLast/255)*2.0;
  const ringThick = ringThickBase * ( ((version>>0)&1) ? 1.8 : 1.0 );
  const ringAlpha = clamp(140 + (luck-1.0)*120, 80, 255);
  const hueShiftDeg = (hashLast/255 - 0.5) * 30; // ±15°
  const shellColorShifted = shiftHue(colors.shell, hueShiftDeg);

  // --- Electron speed array (per shell) + global wobble/breathing
  const base = (timestamp % 600) / 600;
  const noiseSeed = (nonce % 997) / 997;
  const speeds = shells.map((_, i) => (0.005 + (0.018 * fract(sinHash(base + i*0.137 + noiseSeed)))) * speedScale);

  const timeSkew = clamp((timestamp - mediantime)/600, -1, 1);
  const wobbleAmp = map(timeSkew, -1, 1, 0.97, 1.03);  // subtle scale
  const wobbleFreq = 0.5 + Math.abs(timeSkew)*0.8;     // Hz-ish

  // --- Mode from height (name only)
  const mode = height % 4;
  let modeName = '';
  if (mode===0){ modeName='Metal: Swirled'; MARBLE_INT=0.90; MARBLE_SCALE=3.3; }
  else if (mode===1){ modeName='Metal: Brushed'; MARBLE_INT=0.75; MARBLE_SCALE=4.0; }
  else if (mode===2){ modeName='Metal: Geode';   MARBLE_INT=0.65; MARBLE_SCALE=2.6; }
  else {               modeName='Metal: Neon';    MARBLE_INT=0.40; MARBLE_SCALE=2.0; }
  safeText('modeName', modeName);

  return {
    block:{ height, hash, timestamp, mediantime, bits, txCount, weight, size, nonce, version, merkleRoot, modeName, luck: +luck.toFixed(3) },
    height, Z, N, electrons, shells, radii, speeds, electronAngles, nucleusPoints, colors,
    shellTilt, eccA, eccB, eColorMix, eTiltJitter,
    style:{
      eSizeScale, orbitSpread,
      ringThick, ringAlpha, ringColor: shellColorShifted,
      wobbleAmp, wobbleFreq
    }
  };
}

function updateElectrons(a){
  for(let i=0;i<a.shells.length;i++){
    for(let j=0;j<a.shells[i];j++){ a.electronAngles[i][j]+=a.speeds[i]; }
  }
}

/* -------- p5 setup/draw -------- */
window.addEventListener('error', e => setMeta('Error: '+e.message));

function setup(){
  createCanvas(windowWidth, windowHeight, WEBGL);
  setAttributes('antialias', true);
  frameRate(60);

  orbShader = createShader(ORB_VERT, ORB_FRAG);

  for(let i=0;i<BG_STAR_COUNT;i++){
    bgStars.push({x:random(-2800,2800), y:random(-2800,2800), z:random(-2800,2800), s:random(0.4,1.0)});
  }

  document.getElementById('load').addEventListener('click', loadByHeight);
  document.getElementById('latest').addEventListener('click', loadLatest);
  document.getElementById('marbleInt').addEventListener('input', e=>{ MARBLE_INT=parseFloat(e.target.value); safeText('marbleIntVal', MARBLE_INT.toFixed(2)); });
  document.getElementById('marbleScale').addEventListener('input', e=>{ MARBLE_SCALE=parseFloat(e.target.value); safeText('marbleScaleVal', MARBLE_SCALE.toFixed(1)); });
  document.getElementById('fxRings').addEventListener('change', e=>{ FX_RINGS=e.target.checked; });
}

function windowResized(){ resizeCanvas(windowWidth, windowHeight); }

function draw(){
  orbitControl(1,1,1.5);
  background(9,12,15);

  // starfield
  push(); noStroke(); ambientMaterial(200);
  for(const s of bgStars){ push(); translate(s.x,s.y,s.z); sphere(s.s); pop(); }
  pop();

  if(atom){
    const t = millis()*0.001;
    // global spin with a tiny wobble driven by time skew
    rotateY(t*0.07 + Math.sin(t*atom.style.wobbleFreq)*0.02);
    rotateX(Math.sin(t*0.23)*0.05);

    drawAtom(atom, t);
    updateElectrons(atom);
  }
}

function drawAtom(a, time){
  // --- Nucleus (with breathing wobble)
  push();
  const breath = 1.0 + (Math.sin(time * a.style.wobbleFreq*2.0)*0.02) * (a.style.wobbleAmp-1.0);
  scale(breath, 1.0, 1.0);
  for(const p of a.nucleusPoints){
    push(); translate(p.x,p.y,p.z);
    drawOrb(p.isProton? a.colors.proton : a.colors.neutron,
            p.isProton? a.colors.neutron : a.colors.proton,
            NUCLEON_R, time);
    pop();
  }
  pop();

  // --- Shell rings
  if (FX_RINGS){
    for(let i=0;i<a.shells.length;i++){
      const r=a.radii[i];
      push(); noFill();
      stroke(a.style.ringColor[0],a.style.ringColor[1],a.style.ringColor[2], a.style.ringAlpha);
      strokeWeight(a.style.ringThick);
      beginShape();
      const steps=160;
      for(let k=0;k<steps;k++){
        const ang=(k/steps)*TWO_PI;
        vertex(r*Math.cos(ang), r*Math.sin(ang), 0);
      }
      endShape(CLOSE);
      pop();
    }
  }

  // --- Electrons (eccentric orbits, tilt pattern, per-electron color bias)
  for(let i=0;i<a.shells.length;i++){
    const r=a.radii[i];
    const aMul=a.eccA[i], bMul=a.eccB[i];
    for(let j=0;j<a.shells[i];j++){
      const ang=a.electronAngles[i][j];
      const tilt=a.shellTilt[i] + a.eTiltJitter[i][j];

      const ex=(r*aMul)*Math.cos(ang);
      const ey=(r*bMul)*Math.sin(ang)*Math.cos(tilt);
      const ez=(r*bMul)*Math.sin(ang)*Math.sin(tilt);

      const mixT = a.eColorMix[i][j];
      const eCol = mixRGB(a.colors.electron, a.style.ringColor, mixT);

      push(); translate(ex,ey,ez);
      drawOrb(eCol, a.style.ringColor, ELECTRON_R * a.style.eSizeScale, time);
      pop();
    }
  }
}

// Draw one sphere; if shader fails, fall back to solid color
function drawOrb(colorA255, colorB255, radius, time){
  noStroke();
  if (SHADER_OK){
    try{
      shader(orbShader);
      orbShader.setUniform('uColorA', colorA255.map(v=>v/255));
      orbShader.setUniform('uColorB', colorB255.map(v=>v/255));
      orbShader.setUniform('uMarbleInt', MARBLE_INT);
      orbShader.setUniform('uMarbleScale', MARBLE_SCALE);
      orbShader.setUniform('uTime', time);
      sphere(radius);
      resetShader();
      return;
    }catch(e){
      SHADER_OK = false;
      document.getElementById('warn').style.display = 'block';
      console.warn('Shader path failed, using fallback color:', e);
      resetShader();
    }
  }
  ambientMaterial(colorA255[0], colorA255[1], colorA255[2]);
  sphere(radius);
}

/* -------- Data loading & UI -------- */
async function loadByHeight(){
  const val = document.getElementById('height').value.trim();
  if(!val) return setMeta("Enter a block height.");
  const h = parseInt(val,10);
  if(isNaN(h) || h<0) return setMeta("Invalid height.");
  try{
    setMeta("Resolving hash for height "+h+" …");
    const hash = await fetchText(API + "/block-height/" + h);
    if(!hash || hash.length<10) throw new Error("Unexpected response for block height.");
    setMeta("Fetching block "+hash.slice(0,16)+"…");
    const block = await fetchJSON(API + "/block/" + hash);
    atom = buildAtomFromBlock(block);
    setMeta(describeBlock(atom));
    updateBlockPanel(atom);
  }catch(e){ console.error(e); setMeta("Error: "+e.message); }
}
async function loadLatest(){
  try{
    setMeta("Fetching latest block…");
    const arr = await fetchJSON(API + "/blocks");
    if(!Array.isArray(arr) || arr.length===0) throw new Error("No blocks returned.");
    const latest = arr[0];
    const hash = latest.id || latest.hash;
    const block = await fetchJSON(API + "/block/" + hash);
    atom = buildAtomFromBlock(block);
    setMeta(describeBlock(atom));
    updateBlockPanel(atom);
  }catch(e){ console.error(e); setMeta("Error: "+e.message); }
}

async function fetchJSON(url){
  const res = await fetch(url, { headers: { 'accept': 'application/json' } });
  if(!res.ok){ if(res.status===404) throw new Error('Resource not found on mempool.space'); throw new Error(`HTTP ${res.status} on ${url}`); }
  return await res.json();
}
async function fetchText(url){
  const res = await fetch(url, { headers: { 'accept': 'text/plain' } });
  if(!res.ok){ if(res.status===404) throw new Error('Block height not found on mempool.space'); throw new Error(`HTTP ${res.status} on ${url}`); }
  return (await res.text()).trim();
}

function describeBlock(a){
  const b = a.block || {};
  const date = b.timestamp ? new Date(b.timestamp*1000).toLocaleString() : "n/a";
  const mdate = b.mediantime ? new Date(b.mediantime*1000).toLocaleString() : "n/a";
  return `<b>Height:</b> ${b.height ?? 'n/a'}<br/>
          <b>Time:</b> ${date} (median: ${mdate})<br/>
          <b>Tx Count:</b> ${b.txCount ?? 'n/a'}<br/>
          <b>Bits:</b> ${b.bits ?? 'n/a'} &nbsp; <b>Luck:</b> ${b.luck ?? '—'}<br/>
          <b>Merkle Root:</b> ${b.merkleRoot ? escapeHtml(shortHash(b.merkleRoot)) : 'n/a'}<br/>
          <b>Atom:</b> Z=${a.Z} (p), N≈${a.N} (n), e⁻=${a.electrons}, shells=${a.shells.join(', ')}`;
}
function updateBlockPanel(a){
  const b = a.block || {};
  safeText('blkTitle', b.height ? `#${b.height} — ${shortHash(b.hash)}` : '(none loaded)');
  const date = b.timestamp ? new Date(b.timestamp * 1000).toLocaleString() : 'n/a';
  const mdate = b.mediantime ? new Date(b.mediantime * 1000).toLocaleString() : 'n/a';
  const chips = [
    `<span class="chip">Mode: ${b.modeName||'—'}</span>`,
    `<span class="chip">Z=${a.Z}</span>`,
    `<span class="chip">N≈${a.N}</span>`,
    `<span class="chip">e⁻=${a.electrons}</span>`,
    `<span class="chip">shells=[${a.shells.join(', ')}]</span>`,
    `<span class="chip">Luck=${b.luck}</span>`
  ];
  safeHTML('blkBody', `
    <div style="margin-bottom:6px;">${chips.join(' ')}</div>
    <table>
      <tr><td>Height</td><td>${b.height ?? 'n/a'}</td></tr>
      <tr><td>Hash</td><td><code>${shortHash(b.hash)}</code></td></tr>
      <tr><td>Time</td><td>${date} (median: ${mdate})</td></tr>
      <tr><td>Tx count</td><td>${b.txCount ?? 'n/a'}</td></tr>
      <tr><td>Size (bytes)</td><td>${b.size ?? 'n/a'}</td></tr>
      <tr><td>Weight (WU)</td><td>${b.weight ?? 'n/a'}</td></tr>
      <tr><td>Version</td><td>${b.version ?? 'n/a'}</td></tr>
      <tr><td>Bits</td><td>${b.bits ?? 'n/a'}</td></tr>
      <tr><td>Nonce</td><td>${b.nonce ?? 'n/a'}</td></tr>
      <tr><td>Merkle root</td><td><code>${shortHash(b.merkleRoot)}</code></td></tr>
    </table>
  `);
}
</script>
</body>
</html>
