<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bitcoin Block Atom ‚Äî effects + treemap + specials (shader-fixed)</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='8' fill='%2300c2ff'/%3E%3C/svg%3E">
<style>
  :root { --panel:rgba(10,14,18,0.92); --border:#1e2a33; --text:#d9ecff; --muted:#9cc6eb; }
  html,body{margin:0;height:100%;background:#000;color:var(--text);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  #bg2d{position:fixed;inset:0;z-index:0;display:block;pointer-events:none;background:#000}
  canvas.p5canvas{position:fixed;inset:0;z-index:1;display:block;touch-action:none}
  .hud{position:fixed;z-index:20;left:10px;top:10px;display:flex;gap:8px;align-items:center;background:var(--panel);
       border:1px solid var(--border);border-radius:12px;padding:8px 10px;backdrop-filter:blur(6px);font-size:12px}
  .hud input, .hud button{font:inherit;border-radius:8px;border:1px solid var(--border);background:#121820;color:var(--text);padding:6px 8px}
  .panel{position:fixed;z-index:11;font-size:12px;color:var(--muted);padding:8px 10px;background:var(--panel);
         border:1px solid var(--border);border-radius:12px;max-width:min(560px,calc(100vw - 20px));backdrop-filter:blur(6px)}
  #legend{left:10px;top:70px}
  details#blockPanel{right:10px;bottom:10px;max-height:min(80vh,900px);overflow:auto}
  details#blockPanel>summary{list-style:none;cursor:pointer;padding:10px 12px;color:#d7ecff;font-weight:700;display:flex;justify-content:space-between;gap:8px}
  details#blockPanel[open]>summary{border-bottom:1px solid var(--border)}
  details#blockPanel summary::-webkit-details-marker{display:none}
  #blkBody{padding:10px 12px;color:#b7d2ea}
  #blkBody table{border-collapse:collapse;width:100%}
  #blkBody td{padding:4px 0;vertical-align:top}
  #blkBody td:first-child{color:#9cc9ee;width:42%;padding-right:10px}
  .chip{display:inline-block;padding:2px 6px;border:1px solid #2b3a44;border-radius:8px;margin:2px;color:#d7ecff;font-size:11px}
  #infoPanel{left:10px;bottom:10px}
  #infoPanel>summary{list-style:none;cursor:pointer;padding:10px 12px;color:#d7ecff;font-weight:700;display:flex;gap:8px;align-items:center}
  #infoPanel[open]>summary{border-bottom:1px solid var(--border)}
  #infoPanel summary .badge{width:22px;height:22px;display:inline-grid;place-items:center;border-radius:999px;background:#1e2a33;color:#cfe4ff;border:1px solid #2b3a44;font-weight:800}
  #warn{position:fixed;left:10px;top:120px;color:#ffd26f;font-weight:600;display:none;z-index:12}
  #progress{position:fixed;left:10px;top:48px;z-index:21;color:#d7ecff;font-size:12px;background:var(--panel);border:1px solid var(--border);padding:6px 10px;border-radius:10px;display:none}
</style>
</head>
<body>

<canvas id="bg2d"></canvas>

<div class="hud" id="hud">
  <label>Height:</label>
  <input id="heightInput" type="number" min="1" placeholder="e.g. 170 or 840000" style="width:140px"/>
  <button id="loadBtn">Load</button>
  <button id="latestBtn">Latest</button>
</div>
<div id="progress">‚Ä¶</div>

<script src="https://unpkg.com/p5@1.9.2/lib/p5.min.js"></script>
<script>
/* ---------- utils ---------- */
const $=s=>document.querySelector(s);
const shortHash=h=>h?(String(h).slice(0,10)+'‚Ä¶'+String(h).slice(-8)):'n/a';
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const mod=(a,n)=>((a%n)+n)%n;
function XS32(seed){let x=seed>>>0||1;return()=>{x^=x<<13;x^=x>>>17;x^=x<<5;return (x>>>0)/0xFFFFFFFF;};}
function hslToRgb(h,s,l){let r,g,b;if(s===0){r=g=b=l;}else{const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q);b=hue2rgb(p,q,h-1/3);}return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];}
function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;const max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,l=(max+min)/2;if(max===min){h=s=0;}else{const d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return[h,s,l];}
const shiftHue=(rgb,deg)=>{const[h,s,l]=rgbToHsl(rgb[0],rgb[1],rgb[2]);let hh=(h+(deg/360))%1; if(hh<0)hh+=1; return hslToRgb(hh,s,l);};
const lastByte = (hex)=>{ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); if(c.length<2) return 0; return parseInt(c.slice(-2),16)||0; };
const hexByteSum = (hex)=>{ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); let s=0; for(let i=0;i<c.length;i+=2){ const b=parseInt(c.substr(i,2),16); if(!isNaN(b)) s+=b; } return s; };
const byteAt=(hex,idx)=>{ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); if(c.length<2) return 0; const i=(idx*2)%(c.length-1); const b=parseInt(c.substr(i,2),16); return isNaN(b)?0:b; };
const isHalving=h=>h>0&&(h%210000)===0;

/* vec helpers */
const v3=(x,y,z)=>[x,y,z], vadd=(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]];
const vmul=(a,s)=>[a[0]*s,a[1]*s,a[2]*s], vdot=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
const vcross=(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
const vlen=a=>Math.hypot(a[0],a[1],a[2]); const vnorm=a=>{const l=vlen(a)||1; return [a[0]/l,a[1]/l,a[2]/l];};
function rotateAroundAxis(p,u,ang){const c=Math.cos(ang),s=Math.sin(ang),dot=vdot(u,p),cross=vcross(u,p);return vadd(vadd(vmul(p,c),vmul(cross,s)),vmul(u,(1-c)*dot));}

/* ---------- shader (multi-effect) ---------- */
/* IMPORTANT: include aNormal + uNormalMatrix so the program links on all drivers */
const VERT = `
precision mediump float;
attribute vec3 aPosition;
attribute vec3 aNormal;
uniform mat4 uModelViewMatrix, uProjectionMatrix;
uniform mat3 uNormalMatrix;
varying vec3 vPos;
varying vec3 vNormal;
void main(){
  vPos = aPosition;
  vNormal = normalize(uNormalMatrix * aNormal);
  gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(aPosition, 1.0));
}
`;

// uMode: 0=marble,1=glass,2=wireframe,3=lava,4=toon,5=iridescent,6=spikes,7=metallic,8=safe
const FRAG = `
precision mediump float;
varying vec3 vPos;
varying vec3 vNormal;

uniform vec3 uColorA, uColorB;
uniform float uTime;
uniform float uAlpha;
uniform int uMode;
uniform float uPhase;
uniform float uAmp;
uniform float uSpeed;

float hash(vec3 p){ return fract(sin(dot(p, vec3(12.9898,78.233,37.719)))*43758.5453); }
float n3(vec3 p){
  vec3 i=floor(p), f=fract(p);
  float n000=hash(i+vec3(0,0,0)), n100=hash(i+vec3(1,0,0));
  float n010=hash(i+vec3(0,1,0)), n110=hash(i+vec3(1,1,0));
  float n001=hash(i+vec3(0,0,1)), n101=hash(i+vec3(1,0,1));
  float n011=hash(i+vec3(0,1,1)), n111=hash(i+vec3(1,1,1));
  vec3 u=f*f*(3.0-2.0*f);
  float n00=mix(n000,n100,u.x), n10=mix(n010,n110,u.x);
  float n01=mix(n001,n101,u.x), n11=mix(n011,n111,u.x);
  float n0=mix(n00,n10,u.y), n1=mix(n01,n11,u.y);
  return mix(n0,n1,u.z);
}
float fbm(vec3 p){ float s=0.0, a=0.5; for(int i=0;i<5;i++){ s+=a*n3(p); p*=2.02; a*=0.5; } return s; }
vec3 hsv2rgb(vec3 c){ vec3 p=abs(fract(c.xxx+vec3(0.,2./3.,1./3.))*6.-3.); return c.z*mix(vec3(1.0), clamp(p-1.0,0.0,1.0), c.y); }

void main(){
  vec3 n = normalize(vNormal);
  vec3 V = vec3(0.0,0.0,1.0);
  vec3 L1=normalize(vec3(0.6,0.7,0.5));
  vec3 L2=normalize(vec3(-0.4,0.65,-0.2));
  float ndl = max(dot(n,L1),0.0)*0.65 + max(dot(n,L2),0.0)*0.35;
  float rim = pow(1.0 - max(dot(n,V),0.0), 2.0);

  vec3 colA=uColorA, colB=uColorB;
  float t = uTime*(0.6+uSpeed);
  vec3 col;

  if(uMode==0){ // marble
    float s = fbm(normalize(vPos)*3.2 + vec3(0.0, t*0.25+uPhase, 0.0));
    float veins = sin((vPos.x+vPos.y+vPos.z)*8.0 + s*6.0 + uPhase);
    float m = smoothstep(-0.2,0.7,veins);
    vec3 base = mix(colA,colB,m);
    col = base*(0.35+0.65*ndl) + vec3(1.0)*rim*0.12;
  } else if(uMode==1){ // glass
    float fres = pow(1.0 - max(dot(n,V),0.0), 3.0);
    col = mix(colA, colB, 0.5) * (0.08 + 0.15*ndl) + vec3(1.0)*fres*0.85;
  } else if(uMode==2){ // wireframe
    vec3 g=abs(fract(normalize(vPos)*6.0+0.5)-0.5)/(fwidth(normalize(vPos)*6.0)+1e-3);
    float edge = clamp(1.0 - min(min(g.x,g.y),g.z), 0.0, 1.0);
    vec3 base = mix(colA,colB,0.5+0.5*sin(t*0.5));
    col = base*0.2 + vec3(0.2,1.0,0.2)*edge;
  } else if(uMode==3){ // lava
    float f = fbm(normalize(vPos)*4.0 + vec3(0.0,t*0.7,0.0));
    float veins = smoothstep(0.55,0.8,f);
    vec3 hot = vec3(1.0,0.35,0.0);
    vec3 cool = vec3(0.05,0.02,0.02);
    col = mix(cool, hot, veins)* (0.35+0.65*ndl) + vec3(1.0)*rim*0.08;
  } else if(uMode==4){ // toon
    float s = step(0.25,ndl)*0.45 + step(0.55,ndl)*0.3 + step(0.8,ndl)*0.25;
    vec3 base = mix(colA,colB,0.5);
    col = base * (0.2 + s) + vec3(1.0)*step(0.8,rim)*0.2;
  } else if(uMode==5){ // iridescent
    float h = fract(0.5 + 0.35*dot(n,vec3(0.3,0.8,0.5)) + 0.15*sin(t + uPhase));
    vec3 iri = hsv2rgb(vec3(h, 0.9, 1.0));
    col = mix(iri, mix(colA,colB,0.4), 0.3) * (0.3+0.7*ndl) + vec3(1.0)*rim*0.18;
  } else if(uMode==6){ // spikes
    float s = fbm(normalize(vPos)*6.0 + vec3(0.0,t*1.1,0.0));
    float spikes = pow(s, 6.0);
    col = mix(colA,colB, spikes) * (0.25+0.75*ndl) + vec3(1.0)*rim*0.12;
  } else if(uMode==7){ // metallic
    float w = pow(abs(dot(n, normalize(L1+L2))), 32.0);
    col = mix(colA,colB,0.5)*(0.18+0.5*ndl) + vec3(1.0)*w*0.8 + vec3(1.0)*rim*0.1;
  } else {
    col = mix(colA,colB,0.5)*(0.35+0.65*ndl) + vec3(1.0)*rim*0.12;
  }

  gl_FragColor = vec4(clamp(col,0.0,1.0), uAlpha);
}
`;

/* ---------- mapping ---------- */
const NUCLEUS_R0=28, SHELL_STEP=22, ELECTRON_R=3.6, NUCLEON_R=2.7;

function paletteFromHeight(height){
  const rng = XS32(height), golden = 137.50776405003785;
  let baseHue = mod((height * golden) + rng() * 45, 360);
  let hP = baseHue;
  let hN = mod(hP + (90 + rng() * 120), 360);
  let hE = mod(hP + (180 + rng() * 120), 360);
  let hS = mod(hP + (30 + rng() * 120), 360);
  let sP = 0.82 + 0.18 * rng(), lP = 0.48 + 0.12 * rng();
  let sN = 0.72 + 0.25 * rng(), lN = 0.52 + 0.12 * rng();
  let sE = 0.92 + 0.08 * rng(), lE = 0.58 + 0.12 * rng();
  let sS = 0.82 + 0.18 * rng(), lS = 0.56 + 0.12 * rng();
  return{
    proton:  hslToRgb(hP/360, sP, lP),
    neutron: hslToRgb(hN/360, sN, lN),
    electron:hslToRgb(hE/360, sE, lE),
    shell:   hslToRgb(hS/360, sS, lS)
  };
}
function feeSpread(){ return 0.25; }
function fillShells(e){ let shells=[],rem=e,n=1; while(rem>0&&shells.length<8){ const cap=2*n*n; const take=Math.min(rem,cap); shells.push(take); rem-=take; n++; } if(rem>0) shells.push(rem); return shells; }
function styleModeFromHeight(h){ const cycle=[0,3,7,4,2,5,1,6]; return cycle[h % cycle.length]; }

function buildAtomFromBlock(b){
  const height=b.height, txCount=b.tx_count??1, timestamp=b.timestamp??0;
  const nonce=b.nonce??0, merkleRoot=b.merkle_root||"", weight=b.weight??0, size=b.size??0, version=b.version??0, hash=b.id||b.hash||"";
  const colors=paletteFromHeight(height);

  const baseE=(height%118)+1, eJitter=(byteAt(hash,5)%64)-32;
  const electrons=clamp(baseE+eJitter, 6, 180);

  const protonBias=(byteAt(merkleRoot,9)%31)-15;
  const Z=clamp(baseE+protonBias, 6, 160);
  const neutronSkew=((byteAt(hash,2)%101)-50)/180;
  const N=clamp(Math.round(Z*(1.0+neutronSkew)) + (hexByteSum(merkleRoot)%17)-8, 6, 220);

  const shells=fillShells(electrons);

  const prod=Math.max(1, txCount*Math.max(1,size));
  const lgProd=Math.log10(prod);
  const speedScale=clamp((lgProd-8.6)/(10.7-8.6)*(2.2-0.55)+0.55,0.55,2.2);

  const dens=clamp(weight/Math.max(1,size*4),0.6,1.4);
  const tightness=clamp((dens*0.75)+(1.15-0.55*feeSpread()), 0.6,1.4);
  const eccGlobal=clamp(0.08+0.7*feeSpread()+((version&0xF)/60)+((nonce&0x3f)/255)*0.2, 0.08,0.88);

  const hashLast=lastByte(hash);
  const ringThick=0.8+(hashLast/255)*2.0;
  const ringAlpha=220;
  const hueShiftDeg=(hashLast/255-0.5)*36;
  const ringColor=shiftHue(colors.shell, hueShiftDeg);

  const orbitSpread=1.0+((version&0xf)-7.5)*0.01;
  const radii=shells.map((_,i)=>(NUCLEUS_R0*1.3+SHELL_STEP*(i+1))*orbitSpread);

  const electronAngles=[], eMeta=[];
  for(let i=0;i<shells.length;i++){
    electronAngles[i]=[]; eMeta[i]=[];
    for(let j=0;j<shells[i];j++){
      const b0=byteAt(merkleRoot,(i*31+j*11+1)), b1=byteAt(hash,(i*17+j*7+5)), b2=byteAt(merkleRoot,(i*53+j*13+9));
      const seed=(b0<<16)^(b1<<8)^b2;
      let u=vnorm(v3((b0/255)-0.5,(b1/255)-0.5,(b2/255)-0.5)); if(vlen(u)<1e-6) u=[0,0,1];
      const ref=Math.abs(u[2])<0.9?[0,0,1]:[1,0,0]; let v=vnorm(vcross(u,ref)), w=vcross(u,v);
      const e=clamp(eccGlobal*(0.6+0.8*(b1/255)),0.05,0.93), pre=(0.05+0.45*(b2/255))*speedScale, phase=(b0/255)*Math.PI*2;
      const rosK=1+(seed%3), rosAmp=0.03+0.05*(b1/255), spMul=0.6+0.8*(b0/255);
      const hueOffset=( (i*97 + j*131 + seed) % 360 );
      electronAngles[i][j]=(b2/255)*Math.PI*2; eMeta[i][j]={u,v,w,e,pre,phase,rosK,rosAmp,spMul,hueOffset};
    }
  }

  const base=(timestamp%600)/600, noiseSeed=(nonce%997)/997;
  const speeds=shells.map((_,i)=> (0.004+0.015*((Math.sin((base+i*0.137+noiseSeed)*43758.5453)*0.5+0.5)))*speedScale);

  const totalNuc=Math.min(900,Z+N), nucleusPoints=[];
  for(let i=0;i<totalNuc;i++){
    const rNorm=Math.pow(Math.random(), tightness);
    const r=NUCLEUS_R0*(0.35+0.65*rNorm), th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
    const isProton = i<Z;
    const hueOffset = (i*23 + (isProton?177:311)) % 360;
    nucleusPoints.push({x:r*Math.sin(ph)*Math.cos(th),y:r*Math.sin(ph)*Math.sin(th),z:r*Math.cos(ph),isProton,hueOffset});
  }

  const blockPhase=(byteAt(merkleRoot,7)/255)*Math.PI*2;

  const disco = height===170;
  const halving = !disco && isHalving(height);

  let mode = styleModeFromHeight(height);
  if (disco) mode = 5;
  if (halving) mode = 7;

  return {
    block:b,height,Z,N,electrons,shells,radii,speeds,electronAngles,eMeta,nucleusPoints,colors,
    shader:{blockPhase, mode, amp:0.28, speed:0.9},
    style:{
      eSizeScale:clamp((((b.weight||b.size*4)-2.8e6)/(4.0e6-2.8e6))*(1.50-0.90)+0.90,0.7,1.8),
      ringThick, ringAlpha, ringColor, nucleusTight:tightness,
      halving, disco
    }
  };
}

/* ---------- panels ---------- */
let uiPointerDown=false;
function injectPanels(atom){
  ['legend','blockPanel','infoPanel','warn'].forEach(id=>{const n=document.getElementById(id); if(n) n.remove();});

  const legend=document.createElement('div'); legend.id='legend'; legend.className='panel';
  legend.appendChild(document.createElement('div')).innerHTML='<b>Controls</b>';
  ['‚Ä¢ Rotate/Tilt: drag','‚Ä¢ Pan: right-drag / two-finger','‚Ä¢ Zoom: wheel / pinch'].forEach(t=>{ const d=document.createElement('div'); d.textContent=t; legend.appendChild(d); });
  document.body.appendChild(legend);

  const blk=atom.block;
  const det=document.createElement('details'); det.id='blockPanel'; det.className='panel'; det.open=true;
  const sum=document.createElement('summary');
  const sLeft=document.createElement('span'); sLeft.textContent='‚ñº Block Details';
  const sRight=document.createElement('span'); sRight.style.color='#d7dfff'; sRight.style.fontWeight='500';
  sRight.textContent='#'+blk.height+' ‚Äî '+shortHash(blk.id||blk.hash);
  sum.appendChild(sLeft); sum.appendChild(sRight); det.appendChild(sum);

  const body=document.createElement('div'); body.id='blkBody';
  const chips=document.createElement('div'); chips.style.marginBottom='6px';
  [['Electrons',atom.electrons],['Protons',atom.Z],['Neutrons',atom.N]].forEach(([k,v])=>{ const c=document.createElement('span'); c.className='chip'; c.textContent=`${k}: ${v}`; chips.appendChild(c); });
  const modeNames=['Marble','Glass','Wireframe','Lava','Toon','Iridescent','Spikes','Metallic','Safe'];
  const modeName = modeNames[atom.shader.mode] || 'Safe';
  const cm=document.createElement('span'); cm.className='chip'; cm.textContent=`Material: ${modeName}`; chips.appendChild(cm);
  if(atom.style.disco){ const c=document.createElement('span'); c.className='chip'; c.textContent='üéâ Disco 170'; chips.appendChild(c); }
  else if(atom.style.halving){ const c2=document.createElement('span'); c2.className='chip'; c2.textContent='Halving Mode'; chips.appendChild(c2); }
  body.appendChild(chips);

  const tbl=document.createElement('table');
  const rows=[
    ['Tx count', blk.tx_count??'n/a'],
    ['Size (bytes)', blk.size??'n/a'],
    ['Weight (WU)', blk.weight??'n/a'],
    ['Version', blk.version??'n/a'],
    ['Bits', blk.bits??'n/a'],
    ['Nonce', blk.nonce??'n/a'],
    ['Time', (blk.timestamp? new Date(blk.timestamp*1000).toLocaleString():'n/a')],
    ['Merkle root', shortHash(blk.merkle_root)]
  ];
  rows.forEach(([k,v])=>{ const tr=document.createElement('tr'); const td1=document.createElement('td'); td1.textContent=k; const td2=document.createElement('td'); if(k==='Merkle root'){ const code=document.createElement('code'); code.textContent=String(v); td2.appendChild(code);} else td2.textContent=String(v); tr.appendChild(td1); tr.appendChild(td2); tbl.appendChild(tr); });
  body.appendChild(tbl);

  det.appendChild(body); document.body.appendChild(det);

  const info=document.createElement('details'); info.id='infoPanel'; info.className='panel';
  const infoSum=document.createElement('summary'); const badge=document.createElement('span'); badge.className='badge'; badge.textContent='?';
  infoSum.appendChild(badge); infoSum.appendChild(document.createTextNode(' Info / How it works')); info.appendChild(infoSum);
  const infoBody=document.createElement('div'); infoBody.id='infoBody';
  infoBody.innerHTML = '<h3>Visual Mapping</h3>\
  <ul>\
  <li><b>Counts:</b> Electron / proton / neutron counts are derived from height & merkle bytes.</li>\
  <li><b>Speeds:</b> Orbit speed ‚àù log‚ÇÅ‚ÇÄ(tx_count √ó size).</li>\
  <li><b>Orbits:</b> Ellipticity & precession from version/nonce/merkle bytes.</li>\
  <li><b>Colors:</b> Height ‚Üí palette via golden-angle hue; rings hue-shifted by hash.</li>\
  <li><b>Background:</b> Treemap of tx colored by fee rate (0 ‚Üí 50k sat/vB gradient).</li>\
  <li><b>Modes:</b> Material effect chosen from height; Halvings & block 170 override.</li>\
  </ul>\
  <h3>Specials</h3>\
  <p><b>Halving blocks:</b> Pulsing orange backdrop, gold nucleus (rim glow), silver electrons pulsing size.</p>\
  <p><b>Block 170:</b> ROYGBIV rainbow rings & iridescent, independently pulsing, smoothly cycling orbs.</p>';
  info.appendChild(infoBody); document.body.appendChild(info);

  const warn=document.createElement('div'); warn.id='warn'; warn.textContent='Shader fallback active (simplified lighting).'; document.body.appendChild(warn);

  const guard=n=>{n.addEventListener('pointerdown',()=>uiPointerDown=true);n.addEventListener('pointerup',()=>uiPointerDown=false);
                  n.addEventListener('pointerleave',()=>uiPointerDown=false);n.addEventListener('pointercancel',()=>uiPointerDown=false);
                  n.addEventListener('wheel',(e)=>{e.stopPropagation(); e.preventDefault();},{passive:false});};
  [legend,det,info].forEach(guard);
}

/* ---------- treemap background ---------- */
const BG_GREEN=[0x0B,0x4F,0x35], BG_YELLOW=[0xFF,0xFF,0x00], BG_ORANGE=[0xFF,0xA5,0x00], BG_RED=[0xFF,0x00,0x00], BG_PURPLE=[0x81,0x08,0x4E];
const FEERATE_MAX=50000;
const lerp=(a,b,t)=>a+(b-a)*t;
function lerpRGB(a,b,t){return [Math.round(lerp(a[0],b[0],t)),Math.round(lerp(a[1],b[1],t)),Math.round(lerp(a[2],b[2],t))];}
function feeToColor(fr){const t=clamp(fr/FEERATE_MAX,0,1);
  if(t<=0.25){const u=t/0.25;return lerpRGB(BG_GREEN,BG_YELLOW,u);}
  else if(t<=0.50){const u=(t-0.25)/0.25;return lerpRGB(BG_YELLOW,BG_ORANGE,u);}
  else if(t<=0.75){const u=(t-0.50)/0.25;return lerpRGB(BG_ORANGE,BG_RED,u);}
  else{const u=(t-0.75)/0.25;return lerpRGB(BG_RED,BG_PURPLE,clamp(u,0,1));}
}
const bgCanvas=document.getElementById('bg2d'); const bgCtx=bgCanvas.getContext('2d');
let bgBaseCanvas=document.createElement('canvas'), bgBaseCtx=bgBaseCanvas.getContext('2d');
let bgTxs=[]; let DPR=1, bgW=0, bgH=0;
const TREEMAP_GAMMA=0.42, TREEMAP_BASE=120, MIN_RECT_PX=2, BORDER_ALPHA=0.06, BORDER_SKIP_PX=6;
function resizeBG(){
  DPR=Math.min(2,window.devicePixelRatio||1);
  bgW=Math.floor(window.innerWidth); bgH=Math.floor(window.innerHeight);
  for(const c of [bgCanvas,bgBaseCanvas]){ c.width=Math.max(1,Math.floor(bgW*DPR)); c.height=Math.max(1,Math.floor(bgH*DPR)); c.style.width=bgW+'px'; c.style.height=bgH+'px'; }
  for(const ctx of [bgCtx,bgBaseCtx]){ ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR,DPR); }
  if(bgTxs.length){ renderTreemapBase(bgTxs); }
}
window.addEventListener('resize', resizeBG);
function layoutStrip(items,W,H){
  const rects=[]; let y=0,row=[],rowAreaSum=0; const width=W;
  function worstAspect(rowAreas,rowHeight){ if(!rowAreas.length)return Infinity; let worst=0; for(const a of rowAreas){ const w=a/rowHeight; const ar=Math.max(w/rowHeight,rowHeight/w); if(ar>worst) worst=ar;} return worst; }
  let i=0;
  while(i<items.length){
    const a=items[i].area, newRowArea=rowAreaSum+a, newRowHeight=newRowArea/width;
    const currentWorst=worstAspect(row.map(r=>r.area), rowAreaSum?(rowAreaSum/width):newRowHeight);
    const newWorst=worstAspect(row.map(r=>r.area).concat(a), newRowHeight);
    if(row.length && newWorst>currentWorst){
      const h=Math.max(MIN_RECT_PX,rowAreaSum/width); let x=0;
      for(const r of row){ const w=Math.max(MIN_RECT_PX,r.area/h); rects.push({x,y,w,h,color:r.color}); x+=w; }
      y+=h; row=[]; rowAreaSum=0;
    }else{ row.push(items[i]); rowAreaSum=newRowArea; i++; }
  }
  if(row.length){ const h=Math.max(MIN_RECT_PX,rowAreaSum/width); let x=0; for(const r of row){ const w=Math.max(MIN_RECT_PX,r.area/h); rects.push({x,y,w,h,color:r.color}); x+=w; } }
  return rects;
}
function renderTreemapBase(txs){
  bgTxs=txs||[]; const W=bgW,H=bgH;
  bgBaseCtx.clearRect(0,0,W,H); bgBaseCtx.fillStyle="#000"; bgBaseCtx.fillRect(0,0,W,H);
  if(!txs||!txs.length) return;
  const itemsAll=[];
  for(const tx of txs){
    const vsRaw=Math.max(1,tx.vsize||tx.size||1);
    const vs=Math.pow(vsRaw+TREEMAP_BASE,TREEMAP_GAMMA);
    const fr=(tx.fee&&vsRaw)?(tx.fee/vsRaw):0;
    const col=feeToColor(fr);
    const jit=((parseInt((tx.txid||"").slice(-2),16)||0)%10)-5;
    itemsAll.push({weight:vs,color:[clamp(col[0]+jit,0,255),clamp(col[1]+jit,0,255),clamp(col[2]+jit,0,255)],fr});
  }
  itemsAll.sort((a,b)=>a.fr-b.fr); // left‚Üíright low‚Üíhigh

  const isMobile=/Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const CAP=isMobile?6000:12000;
  let items=itemsAll;
  if(itemsAll.length>CAP){ const stride=Math.max(1,Math.floor(itemsAll.length/CAP)); items=[]; for(let i=0;i<itemsAll.length;i+=stride) items.push(itemsAll[i]); }

  const totalW=items.reduce((s,it)=>s+it.weight,0)||1;
  const unitArea=(W*H)/totalW;
  const itemsWithArea=items.map(it=>({area:Math.max(MIN_RECT_PX*MIN_RECT_PX,it.weight*unitArea),color:it.color}));
  const rects=layoutStrip(itemsWithArea,W,H);

  bgBaseCtx.save();
  for(const r of rects){
    bgBaseCtx.fillStyle=`rgb(${r.color[0]},${r.color[1]},${r.color[2]})`;
    bgBaseCtx.fillRect(r.x,r.y,r.w,r.h);
    if(r.w>=BORDER_SKIP_PX && r.h>=BORDER_SKIP_PX){
      bgBaseCtx.strokeStyle=`rgba(255,255,255,${BORDER_ALPHA})`;
      bgBaseCtx.strokeRect(r.x+0.5,r.y+0.5,Math.max(0,r.w-1),Math.max(0,r.h-1));
    }
  }
  bgBaseCtx.restore();
}
function drawBackgroundFrame(atom,t){
  bgCtx.clearRect(0,0,bgW,bgH);
  bgCtx.drawImage(bgBaseCanvas,0,0);
  if(atom.style.halving && !atom.style.disco){
    const pulse=0.5+0.5*Math.sin(t*2.2);
    bgCtx.fillStyle=`rgba(255,140,0,${0.18+0.22*pulse})`;
    bgCtx.fillRect(0,0,bgW,bgH);
  }
}

/* ---------- p5 sketch ---------- */
let p5Instance=null, orbShader=null, SHADER_OK=true;

function startSketch(blk, txsForBg){
  if(p5Instance){ p5Instance.remove(); p5Instance=null; }
  SHADER_OK=true; uiPointerDown=false;

  const atom=buildAtomFromBlock(blk);
  injectPanels(atom);

  const txs=(txsForBg||[]).map(t=>({txid:t.txid, vsize:t.vsize||t.size||1, size:t.size, fee:t.fee||0}));
  resizeBG(); renderTreemapBase(txs);

  const sketch=(p)=>{
    p.setup=function(){
      const cnv=p.createCanvas(p.windowWidth,p.windowHeight,p.WEBGL);
      cnv.canvas.classList.add('p5canvas');
      p.setAttributes('alpha', false);
      p.setAttributes('antialias', true, 'premultipliedAlpha', false);

      try{ orbShader=p.createShader(VERT,FRAG); }
      catch(err){ console.error('Shader creation error:', err); SHADER_OK=false; $('#warn').style.display='block'; }

      // ensure fallback materials are visible if shader fails
      p.ambientLight(120);
      p.directionalLight(255,255,255, 0.5,0.6,0.4);
    };
    p.windowResized=()=>{ p.resizeCanvas(p.windowWidth,p.windowHeight); resizeBG(); renderTreemapBase(txs); };

    function drawOrbMat(cA,cB,r,t,alpha,mode){
      if(!SHADER_OK || !orbShader){
        p.noStroke(); p.fill(cA[0],cA[1],cA[2], Math.round(255*alpha)); p.shininess(20); p.specularMaterial(60);
        p.sphere(r,48,36);
        return;
      }
      try{
        p.noStroke();
        p.shader(orbShader);
        orbShader.setUniform('uColorA', cA.map(v=>v/255));
        orbShader.setUniform('uColorB', cB.map(v=>v/255));
        orbShader.setUniform('uTime', t);
        orbShader.setUniform('uAlpha', alpha);
        orbShader.setUniform('uMode', mode|0);
        orbShader.setUniform('uPhase', atom.shader.blockPhase||0.0);
        orbShader.setUniform('uAmp', atom.shader.amp||0.25);
        orbShader.setUniform('uSpeed', atom.shader.speed||0.9);
        p.sphere(r,64,40);
      }catch(e){
        console.warn('Shader draw error ‚Äî switching to fallback:', e);
        SHADER_OK=false; $('#warn').style.display='block';
        p.resetShader();
        p.noStroke(); p.fill(cA[0],cA[1],cA[2], Math.round(255*alpha)); p.sphere(r,48,36);
      }finally{
        if (SHADER_OK) p.resetShader();
      }
    }

    function hueToRgb(h){ return hslToRgb((h%360)/360, 0.95, 0.55); }
    function drawRainbowRingsFull(t){
      const steps=360;
      for(let i=0;i<atom.shells.length;i++){
        const r=atom.radii[i];
        p.push(); p.noFill(); p.strokeWeight(1.8);
        p.beginShape();
        for(let k=0;k<=steps;k++){
          const ang=(k/steps)*Math.PI*2;
          const hue = ( (k/steps)*360 + t*160 + i*15 ) % 360;
          const c=hueToRgb(hue);
          p.stroke(c[0],c[1],c[2],230);
          p.vertex(r*Math.cos(ang), r*Math.sin(ang), 0);
        }
        p.endShape(); p.pop();
      }
    }

    p.draw=function(){
      const t=p.millis()*0.001;
      drawBackgroundFrame(atom, t);

      p.background(0);
      const gl=p._renderer.GL; gl.clearDepth(1.0); gl.clear(gl.DEPTH_BUFFER_BIT);

      const s=uiPointerDown?0:1; p.orbitControl(s,s,1.5);
      p.rotateY(t*0.06); p.rotateX(Math.sin(t*0.23)*0.05);

      // Rings
      if(atom.style.disco){ drawRainbowRingsFull(t); }
      else{
        for(let i=0;i<atom.shells.length;i++){
          const r=atom.radii[i];
          p.push(); p.noFill();
          if(atom.style.halving){ p.stroke(255,170,0,200); p.strokeWeight(1.6+0.8*Math.sin(t*2.0+i)); }
          else{ p.stroke(atom.style.ringColor[0],atom.style.ringColor[1],atom.style.ringColor[2],atom.style.ringAlpha); p.strokeWeight(atom.style.ringThick); }
          p.beginShape(); const steps=200; for(let k=0;k<steps;k++){ const ang=(k/steps)*Math.PI*2; p.vertex(r*Math.cos(ang), r*Math.sin(ang), 0); }
          p.endShape(p.CLOSE); p.pop();
        }
      }

      // Nucleus
      p.push();
      for(const q of atom.nucleusPoints){
        p.push(); p.translate(q.x,q.y,q.z);
        if (atom.style.disco){
          const hue = (t*240 + q.hueOffset) % 360;
          const col = hueToRgb(hue);
          const pulse = 1.0 + 0.35*Math.sin(t*9.0 + q.hueOffset*0.05);
          drawOrbMat(col, col, NUCLEON_R*pulse, t, 1.0, 5);
        } else if(atom.style.halving){
          const goldA=[255,215,64], goldB=[255,170,32];
          drawOrbMat(goldA, goldB, NUCLEON_R, t, 1.0, 7);
        } else {
          if(q.isProton){
            drawOrbMat(atom.colors.proton, shiftHue(atom.colors.proton,18), NUCLEON_R, t, 1.0, 0);
          } else {
            drawOrbMat(shiftHue(atom.colors.neutron,-22), atom.colors.neutron, NUCLEON_R, t, 1.0, 7);
          }
        }
        p.pop();
      }
      p.pop();

      // Electrons
      for(let i=0;i<atom.shells.length;i++){
        const r=atom.radii[i], baseSpeed=atom.speeds[i];
        for(let j=0;j<atom.shells[i];j++){
          const m=atom.eMeta[i][j]; let th=atom.electronAngles[i][j];
          const a=r*(1+m.e*0.35), b=r*(1-m.e*0.35);
          const pre=t*m.pre + m.phase;
          const v=rotateAroundAxis(m.v,m.u,pre), w=rotateAroundAxis(m.w,m.u,pre);
          const basePt=vadd(vmul(v,a*Math.cos(th)), vmul(w,b*Math.sin(th)));
          const wob=1.0 + m.rosAmp*Math.sin(th*m.rosK + m.phase*0.7);
          const pt=vmul(basePt, wob);

          p.push(); p.translate(pt[0],pt[1],pt[2]);
          if (atom.style.disco){
            const hue = (t*240 + m.hueOffset) % 360;
            const col = hueToRgb(hue);
            const pulse = 1.0 + 0.35*Math.sin(t*9.5 + m.hueOffset*0.07);
            drawOrbMat(col, col, ELECTRON_R*atom.style.eSizeScale*pulse, t, 1.0, 5);
          } else if (atom.style.halving){
            const silverA=[220,228,235], silverB=[160,170,185];
            const pulse=1.0+0.30*Math.sin(t*3.2+i*0.7+j*0.21);
            drawOrbMat(silverA, silverB, ELECTRON_R*atom.style.eSizeScale*pulse, t, 1.0, 7);
          } else {
            const modeCycle=[0,3,2,1,6,4,7,5];
            const mode=modeCycle[(i+j+atom.shader.mode)%modeCycle.length];
            const mixT=((j%7)/7)*0.35;
            const eCol=[
              Math.round(atom.colors.electron[0]*(1-mixT)+atom.style.ringColor[0]*mixT),
              Math.round(atom.colors.electron[1]*(1-mixT)+atom.style.ringColor[1]*mixT),
              Math.round(atom.colors.electron[2]*(1-mixT)+atom.style.ringColor[2]*mixT),
            ];
            drawOrbMat(eCol, atom.style.ringColor, ELECTRON_R*atom.style.eSizeScale, t, 1.0, mode);
          }
          p.pop();

          atom.electronAngles[i][j]+=baseSpeed*m.spMul;
        }
      }
    };
  };

  const container=document.createElement('div'); container.style.position='fixed'; container.style.inset='0'; container.style.zIndex='1';
  document.body.appendChild(container);
  p5Instance=new p5(sketch, container);
}

/* ---------- networking ---------- */
const API='https://mempool.space/api';
async function fetchText(u){const r=await fetch(u); if(!r.ok) throw new Error(r.status+' '+u); return (await r.text()).trim();}
async function fetchJSON(u){const r=await fetch(u); if(!r.ok) throw new Error(r.status+' '+u); return r.json();}

async function fetchAllBlockTxs(hash){
  const txs = [];
  const pageSize = 25;
  let page = 0;
  while (true) {
    try {
      const arr = await fetchJSON(`${API}/block/${hash}/txs/${page}`);
      if (!arr || !arr.length) break;
      for (const t of arr) {
        txs.push({ txid: t.txid || t.hash, vsize: t.vsize || t.size, size: t.size, fee: t.fee });
      }
      if (arr.length < pageSize) break;
      page += 1;
    } catch (err) {
      console.warn(`stop paging at /txs/${page}:`, err?.message || err);
      break;
    }
  }
  return txs;
}

async function loadBlockByHeight(height){
  $('#progress').style.display='block'; $('#progress').textContent='Resolving block '+height+'‚Ä¶';
  const hash=await fetchText(API+'/block-height/'+height);
  $('#progress').textContent='Fetching header‚Ä¶';
  const blk=await fetchJSON(API+'/block/'+hash);
  $('#progress').textContent='Fetching transactions‚Ä¶';
  const txs=await fetchAllBlockTxs(hash);
  $('#progress').style.display='none';
  startSketch(blk, txs);
}
async function loadLatest(){
  $('#progress').style.display='block'; $('#progress').textContent='Getting tip height‚Ä¶';
  const h=await fetchText(API+'/blocks/tip/height'); $('#heightInput').value=h;
  await loadBlockByHeight(h);
}

/* ---------- HUD + guards ---------- */
['pointerdown','wheel'].forEach(ev=>$('#hud').addEventListener(ev,()=>{uiPointerDown=true;},{passive:false}));
['pointerup','pointerleave','pointercancel'].forEach(ev=>$('#hud').addEventListener(ev,()=>{uiPointerDown=false;}));

document.getElementById('loadBtn').onclick=async()=>{const h=Number(document.getElementById('heightInput').value); if(!h){alert('Enter a block height'); return;}
  try{ await loadBlockByHeight(h);}catch(e){ document.getElementById('progress').textContent='Error: '+e.message; }};
document.getElementById('latestBtn').onclick=async()=>{ try{ await loadLatest(); }catch(e){ document.getElementById('progress').textContent='Error: '+e.message; }};

resizeBG();
// loadLatest(); // optional autoload
</script>
</body>
</html>
