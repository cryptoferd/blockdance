<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Bitcoin Block Atom — mobile-friendly controls</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='8' fill='%2300c2ff'/%3E%3C/svg%3E">
<style>
  :root{--panel:rgba(10,14,18,0.92);--border:#1e2a33;--text:#d9ecff;--muted:#9cc6eb}
  html,body{margin:0;height:100%;background:#000;color:var(--text);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  canvas{display:block;touch-action:none}
  /* HUD */
  .hud{position:fixed;z-index:20;left:12px;right:12px;top:12px;background:var(--panel);border:1px solid var(--border);
       border-radius:14px;padding:10px;backdrop-filter:blur(6px);display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .hud input,.hud button,.hud select{font:inherit;border-radius:10px;border:1px solid var(--border);background:#121820;color:var(--text);padding:8px 10px}
  .hud label{opacity:.9}
  .btn{cursor:pointer}
  .panel{position:fixed;z-index:12;background:var(--panel);border:1px solid var(--border);border-radius:14px;color:#cfe4ff;
         padding:10px 12px;max-width:min(480px,calc(100vw-24px));backdrop-filter:blur(6px);font-size:14px}
  #legend{left:12px;top:86px}
  details#infoPanel{left:12px;bottom:12px}
  details summary{cursor:pointer;list-style:none;display:flex;align-items:center;gap:8px}
  details summary::-webkit-details-marker{display:none}
  .badge{width:24px;height:24px;display:grid;place-items:center;border-radius:999px;background:#1e2a33;border:1px solid #2b3a44}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:14px;padding:8px 12px;background:#0009;color:#dfefff;border:1px solid #2b3a44;border-radius:10px;z-index:25;opacity:.85;transition:opacity .7s ease}
  .hide{display:none !important}
  @media (max-width: 720px){
    .hud{gap:8px}
    .hud input,.hud button,.hud select{padding:7px 9px}
  }
</style>
</head>
<body>

<!-- HUD -->
<div class="hud" id="hud">
  <div class="row">
    <label for="heightInput">Height:</label>
    <input id="heightInput" type="number" min="1" style="width:140px"/>
    <button id="loadBtn" class="btn">Load</button>
    <button id="latestBtn" class="btn">Latest</button>
    <button id="resetBtn" class="btn">Reset View</button>
  </div>
</div>

<!-- Controls legend -->
<div class="panel" id="legend">
  <b>Controls</b>
  <div>• Rotate/Tilt: drag / 1-finger</div>
  <div>• Pan: right-drag / 2-finger drag</div>
  <div>• Zoom: wheel / pinch</div>
</div>

<!-- Info -->
<details id="infoPanel" class="panel" open>
  <summary><span class="badge">?</span> Info / How it works</summary>
  <div style="margin-top:6px;opacity:.9">
    <p>This build focuses on mobile/desktop controls. Press <b>E</b> (desktop) or <b>double-tap</b> (mobile) to toggle the UI.</p>
    <p>Use <i>Reset View</i> to restore the original camera.</p>
  </div>
</details>

<!-- Quick hint that fades after 15s -->
<div id="hint" class="toast">Press <b>E</b> or <b>double-tap</b> to toggle UI</div>

<script src="https://unpkg.com/p5@1.9.2/lib/p5.min.js"></script>
<script>
/* ============================================================
   Minimal “atom” scene so we can focus on the camera & input
   ============================================================ */
const TWO_PI = Math.PI*2;
const NUCLEON_R = 5, ELECTRON_R = 4;
const SHELL_STEP = 85, NUCLEUS_R0 = 60;

const $ = s => document.querySelector(s);

/* ---------- Camera state ---------- */
const cam = {
  theta: 0,         // yaw (left/right)
  phi:   0.25,      // pitch (up/down)
  dist:  780,       // distance from target
  tx:    0, ty: 0, tz: 0, // target
  spin:  0.35 * Math.PI/180, // coin-like idle spin (radians / frame)
  minDist: 50,
  maxDist: 5000
};
const defaults = JSON.parse(JSON.stringify(cam));

let isPointerDown = false;
let isPanning = false;
let isPinching = false;
let lastX = 0, lastY = 0;
let baseDist = cam.dist;
let pinchBase = 1;
let idle = true;      // no interaction → slow spin
let uiVisible = true; // toggled by E or double-tap
let multiTouch = new Map();

/* ---------- Simple deterministic atom ---------- */
function makeAtom(seed=840000){
  const rand = (s=>()=> (s^=s<<13, s^=s>>>17, s^=s<<5, (s>>>0)/0xFFFFFFFF))(seed>>>0);
  const electrons = 36 + Math.floor(rand()*30);
  const shells = [];
  let remaining = electrons, n=1;
  while(remaining>0 && shells.length<7){ const cap=2*n*n; const take=Math.min(remaining,cap); shells.push(take); remaining-=take; n++; }
  const radii = shells.map((_,i)=>NUCLEUS_R0+SHELL_STEP*(i+1));
  const nucleus = [];
  const totalN = 80 + Math.floor(rand()*60);
  for(let i=0;i<totalN;i++){
    const r = NUCLEUS_R0*0.45 * Math.pow(rand(), 0.55);
    const th = rand()*TWO_PI, ph = Math.acos(2*rand()-1);
    nucleus.push([r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph)]);
  }
  return {shells,radii,nucleus};
}
const atom = makeAtom();

/* ---------- Helpers ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function toCam(p){ // returns eye, center, up from cam state
  const c = Math.cos(cam.theta), s = Math.sin(cam.theta);
  const cp = Math.cos(cam.phi), sp = Math.sin(cam.phi);
  // forward (from target toward camera)
  const fx = c*cp, fy = sp, fz = s*cp;
  const eye = [cam.tx + fx*cam.dist, cam.ty + fy*cam.dist, cam.tz + fz*cam.dist];
  // camera right & up if needed
  const up = [ -c*sp, cp, -s*sp ];
  return {eye, center:[cam.tx,cam.ty,cam.tz], up};
}
function resetView(){ Object.assign(cam, defaults); }

/* ---------- UI toggle (desktop & mobile) ---------- */
function setUIVisible(v){
  uiVisible = v;
  const display = v ? '' : 'none';
  ['hud','legend','infoPanel'].forEach(id => { const n=$( '#'+id ); if(n) n.style.display = display; });
}
function toggleUI(){ setUIVisible(!uiVisible); }

/* double-tap detector (mobile) */
let lastTapTime = 0;
function handleTapToggle(){
  const now = performance.now();
  if (now - lastTapTime < 320){ toggleUI(); lastTapTime = 0; }
  else lastTapTime = now;
}

/* Fade the hint after 15s */
setTimeout(()=>{ const h=$('#hint'); if(h) h.style.opacity=0; setTimeout(()=>h.remove(), 800); }, 15000);

/* ---------- p5 sketch ---------- */
let p5i = null;

function startSketch(){
  if(p5i){ p5i.remove(); p5i=null; }
  p5i = new p5((p)=>{

    p.setup = function(){
      p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
      p.setAttributes('antialias', true);
      // friendlier clip planes so zooming very close doesn’t “pop” away
      p.perspective(p.PI/3, p.width/p.height, 0.1, 20000);
      attachCanvasEvents(p);
    };

    p.windowResized = function(){ p.resizeCanvas(p.windowWidth, p.windowHeight); };

    p.draw = function(){
      p.background(0);
      const {eye,center,up} = toCam();
      p.camera(eye[0],eye[1],eye[2], center[0],center[1],center[2], up[0],up[1],up[2]);

      // idle coin-spin when not interacting
      if (idle && !isPointerDown && !isPanning && !isPinching){
        cam.theta += cam.spin;  // vertical axis spin
      }

      // lighting
      p.ambientLight(24);
      p.directionalLight(200,200,200, 0.7,0.8,0.6);
      p.directionalLight(160,160,200, -0.6,0.5,-0.3);

      // rings
      p.push();
      p.noFill();
      p.stroke(255,140,140,190); p.strokeWeight(2);
      for(let i=0;i<atom.shells.length;i++){
        const r = atom.radii[i];
        p.beginShape();
        for(let a=0;a<=180;a++){ const ang=a/180*TWO_PI; p.vertex(Math.cos(ang)*r, Math.sin(ang)*r, 0); }
        p.endShape();
      }
      p.pop();

      // nucleus (plain for control testing)
      p.push();
      p.noStroke(); p.ambientMaterial(240,190,255,230);
      for(const q of atom.nucleus){ p.push(); p.translate(q[0],q[1],q[2]); p.sphere(NUCLEON_R); p.pop(); }
      p.pop();

      // electrons (plain)
      p.push();
      p.noStroke(); p.specularMaterial(180,210,255,200); p.shininess(40);
      let idx=0;
      for(let i=0;i<atom.shells.length;i++){
        const r = atom.radii[i];
        const k = atom.shells[i];
        for(let j=0;j<k;j++){
          const a = (j/k)*TWO_PI + (p.frameCount*0.01 + i*0.2);
          const x = Math.cos(a)*r, y=Math.sin(a)*r;
          const z = Math.sin(a*1.3 + i*0.7)*40;
          p.push(); p.translate(x,y,z); p.sphere(ELECTRON_R); p.pop();
          idx++;
        }
      }
      p.pop();
    };
  });
}

/* ---------- Canvas interactions ---------- */
function attachCanvasEvents(p){
  const c = p._renderer?.canvas;
  if(!c) return;

  // prevent default gestures on canvas
  c.style.touchAction = 'none';

  // Wheel zoom (natural: up = zoom in)
  c.addEventListener('wheel',(e)=>{
    e.preventDefault();
    idle = false;
    const factor = Math.exp(-e.deltaY * 0.0016);
    cam.dist = clamp(cam.dist * factor, cam.minDist, cam.maxDist);
  }, {passive:false});

  // Pointer events (mouse & touch)
  c.addEventListener('pointerdown',(e)=>{
    c.setPointerCapture(e.pointerId);
    multiTouch.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(multiTouch.size===1){
      isPointerDown = true; isPanning = (e.button===2); // right button pans
      lastX = e.clientX; lastY = e.clientY;
    } else if(multiTouch.size===2){
      // begin pinch / pan with 2 fingers
      isPinching = true; isPanning = true; isPointerDown = false;
      const pts = [...multiTouch.values()];
      pinchBase = dist2(pts[0], pts[1]);
      baseDist = cam.dist;
      lastX = (pts[0].x + pts[1].x)/2;
      lastY = (pts[0].y + pts[1].y)/2;
    }
    idle = false;
  });

  c.addEventListener('pointermove',(e)=>{
    if(!multiTouch.has(e.pointerId)) return;
    multiTouch.set(e.pointerId, {x:e.clientX, y:e.clientY});

    if(isPinching && multiTouch.size>=2){
      const pts = [...multiTouch.values()];
      const centerX = (pts[0].x + pts[1].x)/2;
      const centerY = (pts[0].y + pts[1].y)/2;

      // pinch zoom
      const d = dist2(pts[0], pts[1]);
      const scale = clamp(d / Math.max(1, pinchBase), 0.25, 4.0);
      cam.dist = clamp(baseDist / scale, cam.minDist, cam.maxDist); // inward pinch => smaller dist

      // two-finger pan (screen-space)
      const dx = centerX - lastX;
      const dy = centerY - lastY;
      applyPan(dx, dy);

      lastX = centerX; lastY = centerY;
    } else if(isPointerDown){
      // 1-finger / left-drag = rotate, 1-finger right-drag = pan
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      if(isPanning){
        applyPan(dx, dy);
      }else{
        // natural mapping: up→up, left→left
        cam.theta -= dx * 0.0050;
        cam.phi   = clamp(cam.phi - dy * 0.0030, -Math.PI/2+0.05, Math.PI/2-0.05);
      }
      lastX = e.clientX; lastY = e.clientY;
    }
  });

  c.addEventListener('pointerup',(e)=>{
    multiTouch.delete(e.pointerId);
    if(multiTouch.size===0){ isPointerDown=false; isPanning=false; isPinching=false; idle=true; }
    if(multiTouch.size===1){ // revert to single-finger mode if one remains
      const [only] = multiTouch.values();
      lastX = only.x; lastY = only.y;
      isPinching=false;
    }
  });
  c.addEventListener('pointercancel',()=>{ multiTouch.clear(); isPointerDown=false; isPanning=false; isPinching=false; idle=true; });

  // Context menu off so right-drag pans
  c.addEventListener('contextmenu', e=>e.preventDefault());

  // Double-tap to toggle UI (mobile)
  c.addEventListener('pointerdown', (e)=>{
    if(e.pointerType==='touch'){ handleTapToggle(); }
  });
}

function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

function applyPan(dx, dy){
  // screen-space pan → world-space target move, invariant to rotation
  const cosT = Math.cos(cam.theta), sinT = Math.sin(cam.theta);
  const cosP = Math.cos(cam.phi),   sinP = Math.sin(cam.phi);

  // camera right vector
  const rx = -sinT, ry = 0, rz = cosT;
  // camera up vector
  const ux = -cosT*sinP, uy = cosP, uz = -sinT*sinP;

  const panScale = cam.dist * 0.0015; // proportional to distance
  cam.tx += (-dx*rx + dy*ux) * panScale; // signs chosen so drag feels natural
  cam.ty += (-dx*ry + dy*uy) * panScale;
  cam.tz += (-dx*rz + dy*uz) * panScale;
}

/* ---------- Buttons & keyboard ---------- */
$('#resetBtn').onclick = ()=>{ resetView(); idle=true; };

$('#loadBtn').onclick = async ()=>{
  // stub — you can wire back to mempool as before
  const h = Number($('#heightInput').value||840000); (void)h;
  resetView(); idle=true;
};
$('#latestBtn').onclick = async ()=>{
  resetView(); idle=true;
};

window.addEventListener('keydown',(e)=>{
  if(e.key.toLowerCase()==='e'){ toggleUI(); }
});

/* ---------- Boot ---------- */
startSketch();
$('#heightInput').value = 840000;
</script>
</body>
</html>
