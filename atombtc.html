<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Bitcoin Block Atom â€” full render (nucleus + electrons)</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='8' fill='%2300c2ff'/%3E%3C/svg%3E">
<style>
  :root { --panel:rgba(10,14,18,0.94); --border:#1e2a33; --text:#d9ecff; --muted:#9cc6eb; }
  html,body{margin:0;height:100%;background:#000;color:var(--text);
            font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  canvas.p5canvas{position:fixed;inset:0;z-index:1;display:block;touch-action:none}

  .uiRoot{position:fixed;inset:0;z-index:30;opacity:1;visibility:visible;pointer-events:none}
  .uiRoot.show{opacity:1;visibility:visible}
  .uiRoot.show *{pointer-events:auto}

  .hud{position:fixed;left:12px;top:12px;display:flex;gap:8px;align-items:center;background:var(--panel);
       border:1px solid var(--border);border-radius:12px;padding:8px 10px;backdrop-filter:blur(6px);font-size:12px;z-index:31}
  .hud input, .hud button, .hud select{font:inherit;border-radius:8px;border:1px solid var(--border);
       background:#121820;color:var(--text);padding:6px 8px}
  .hud button{cursor:pointer}
  .hud .sep{width:1px;height:24px;background:#283543;margin:0 6px}

  .panel{position:fixed;font-size:12px;color:var(--muted);padding:8px 10px;background:var(--panel);
         border:1px solid var(--border);border-radius:12px;max-width:min(580px,calc(100vw - 24px));backdrop-filter:blur(6px)}
  #legend{left:12px;top:78px;z-index:31}
  #legend div{white-space:nowrap}

  details#blockPanel{right:12px;bottom:12px;max-height:min(80vh,900px);overflow:auto;z-index:31}
  details#blockPanel>summary{list-style:none;cursor:pointer;padding:10px 12px;color:#d7ecff;font-weight:700;
                             display:flex;justify-content:space-between;gap:8px}
  details#blockPanel[open]>summary{border-bottom:1px solid var(--border)}
  details#blockPanel summary::-webkit-details-marker{display:none}
  #blkBody{padding:10px 12px;color:#b7d2ea}
  #blkBody table{border-collapse:collapse;width:100%}
  #blkBody td{padding:4px 0;vertical-align:top}
  #blkBody td:first-child{color:#9cc9ee;width:42%;padding-right:10px}
  .chip{display:inline-block;padding:2px 6px;border:1px solid #2b3a44;border-radius:8px;margin:2px;
        color:#d7ecff;font-size:11px}

  #infoPanel{left:12px;bottom:12px;z-index:31}
  #infoPanel>summary{list-style:none;cursor:pointer;padding:10px 12px;color:#d7ecff;font-weight:700;
                     display:flex;gap:8px;align-items:center}
  #infoPanel[open]>summary{border-bottom:1px solid var(--border)}
  #infoPanel summary .badge{width:22px;height:22px;display:inline-grid;place-items:center;border-radius:999px;
                            background:#1e2a33;color:#cfe4ff;border:1px solid #2b3a44;font-weight:800}

  #progress{position:fixed;left:12px;top:12px;transform:translateY(52px);z-index:40;color:#d7ecff;font-size:12px;
            background:var(--panel);border:1px solid var(--border);padding:6px 10px;border-radius:10px;display:none;max-width:min(70vw,740px);white-space:pre-line}
  #hint{position:fixed;left:50%;bottom:12px;transform:translateX(-50%);z-index:35;color:#b6c9de;opacity:0.35;font-size:12px;
        background:rgba(7,10,14,0.6);border:1px solid #24313b;border-radius:10px;padding:7px 10px;pointer-events:none;transition:opacity .4s ease}
  #hint.hide{opacity:0}

  @media (max-width: 800px){
    .hud{
      left:8px; right:8px; top:8px;
      display:grid; grid-template-columns: 1fr auto auto auto; grid-auto-rows:minmax(36px,auto); gap:8px;
      font-size:13px
    }
    .hud .sep{display:none}
    #legend{left:8px; top:auto; bottom:calc(env(safe-area-inset-bottom,0px) + 96px)}
    details#blockPanel, #infoPanel{left:8px; right:8px; max-width:none}
  }
</style>
</head>
<body>

<div class="uiRoot show" id="uiRoot">
  <div class="hud" id="hud">
    <label>Height:</label>
    <input id="heightInput" type="number" min="1" placeholder="e.g. 170 or 840000"/>
    <button id="loadBtn">Load</button>
    <button id="latestBtn">Latest</button>
    <button id="resetBtn" title="Reset view to original">Reset View</button>
    <span class="sep"></span>
    <span>Protons</span>
    <select id="selProton"></select>
    <span>Neutrons</span>
    <select id="selNeutron"></select>
    <span>Electrons</span>
    <select id="selElectron"></select>
  </div>

  <div class="panel" id="legend">
    <div><b>Controls</b></div>
    <div>â€¢ Rotate/Tilt: drag / 1-finger</div>
    <div>â€¢ Pan: right-drag / 2-finger drag</div>
    <div>â€¢ Zoom: wheel / pinch</div>
  </div>

  <details id="blockPanel" class="panel"></details>
  <details id="infoPanel"  class="panel"></details>
</div>

<div id="progress">â€¦</div>
<div id="hint">Press <b>E</b> (desktop) or <b>double-tap</b> the scene (mobile) to show / hide the UI</div>

<script src="https://unpkg.com/p5@1.9.2/lib/p5.min.js"></script>
<script>
/* ---------- utils ---------- */
const $=s=>document.querySelector(s);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const mod=(a,n)=>((a%n)+n)%n;
const shortHash=h=>h?(String(h).slice(0,10)+'â€¦'+String(h).slice(-8)):'n/a';
function XS32(seed){let x=seed>>>0||1;return()=>{x^=x<<13;x^=x>>>17;x^=x<<5;return (x>>>0)/0xFFFFFFFF;};}
function hslToRgb(h,s,l){let r,g,b;if(s===0){r=g=b=l;}else{const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q);b=hue2rgb(p,q,h-1/3);}return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];}
function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;const max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,l=(max+min)/2;if(max===min){h=s=0;}else{const d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return[h,s,l];}
const shiftHue=(rgb,deg)=>{const[h,s,l]=rgbToHsl(rgb[0],rgb[1],rgb[2]);let hh=(h+(deg/360))%1; if(hh<0)hh+=1; return hslToRgb(hh,s,l);};
const lastByte = (hex)=>{ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); if(c.length<2) return 0; return parseInt(c.slice(-2),16)||0; };
const hexByteSum = (hex)=>{ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); let s=0; for(let i=0;i<c.length;i+=2){ const b=parseInt(c.substr(i,2),16); if(!isNaN(b)) s+=b; } return s; };
const byteAt=(hex,idx)=>{ if(!hex) return 0; const c=hex.replace(/[^0-9a-fA-F]/g,''); if(c.length<2) return 0; const i=(idx*2)%(c.length-1); const b=parseInt(c.substr(i,2),16); return isNaN(b)?0:b; };
const mixRGB=(a,b,t)=>[Math.round(a[0]*(1-t)+b[0]*t),Math.round(a[1]*(1-t)+b[1]*t),Math.round(a[2]*(1-t)+b[2]*t)];
const TAU = Math.PI*2;
const isFiniteVec = v => v.every(Number.isFinite);

/* ---------- shaders ---------- */
const VERT=`precision mediump float; precision mediump int;
attribute vec3 aPosition;
uniform mat4 uModelViewMatrix,uProjectionMatrix;
uniform float uModeF,uTime,uAmp,uSpeed,uObjSeed;
varying vec3 vPos,vNormal;
float hash(vec3 p){return fract(sin(dot(p,vec3(12.9898,78.233,37.719)))*43758.5453);}
float n3(vec3 p){vec3 i=floor(p),f=fract(p);
float n000=hash(i+vec3(0,0,0)), n100=hash(i+vec3(1,0,0));
float n010=hash(i+vec3(0,1,0)), n110=hash(i+vec3(1,1,0));
float n001=hash(i+vec3(0,0,1)), n101=hash(i+vec3(1,0,1));
float n011=hash(i+vec3(0,1,1)), n111=hash(i+vec3(1,1,1));
vec3 u=f*f*(3.0-2.0*f);
float n00=mix(n000,n100,u.x), n10=mix(n010,n110,u.x);
float n01=mix(n001,n101,u.x), n11=mix(n011,n111,u.x);
float n0=mix(n00,n10,u.y), n1=mix(n01,n11,u.y);
return mix(n0,n1,u.z);}
float fbm(vec3 p){float s=0.0,a=0.5;for(int i=0;i<5;i++){s+=a*n3(p);p*=2.03;a*=0.5;}return s;}
void main(){
  vec3 pos=aPosition;
  vec3 nrm=normalize(aPosition);
  int m=int(floor(clamp(uModeF,0.0,10.0)+0.5));

  // Spikes (m==6)
  if(m==6){
    vec3 seed=vec3(uObjSeed,uObjSeed*1.9,uObjSeed*2.7);
    float t=uTime*(1.0+uSpeed);
    float s=fbm(normalize(pos)*6.5 + seed + vec3(0.0,t*1.1,0.0));
    float spike=smoothstep(0.55,0.93,s);
    float amp=6.5*(0.65+0.35*uAmp);
    pos += nrm*(amp*spike*length(aPosition));
  }

  // Glass (m==1)
  if(m==1){
    float t=uTime*(0.5*(1.0+0.6*uSpeed));
    float w1 = sin( dot(nrm, vec3(0.8,0.2,0.5))*22.0 + t*2.2 + uObjSeed*11.7 );
    float w2 = sin( dot(nrm, vec3(-0.3,0.9,0.1))*17.0 + t*1.6 + uObjSeed*7.3 );
    float j  = fbm(nrm*5.0 + vec3(0.0,t*0.4,0.0) + vec3(uObjSeed));
    float ripple = (w1*0.6 + w2*0.4) * (0.012 + 0.008*j) * (0.7+0.3*uAmp) * 10.0;
    pos += nrm * ripple * length(aPosition);
  }

  // Fireball (m==9): keep orb size (no surface expansion)
  if(m==9){}

  vPos=pos; vNormal=normalize(pos);
  gl_Position=uProjectionMatrix*(uModelViewMatrix*vec4(pos,1.0));
}`;

const FRAG=`precision mediump float; precision mediump int;
varying vec3 vPos,vNormal;
uniform vec3 uColorA,uColorB;
uniform float uTime,uAlpha,uPhase,uAmp,uSpeed,uModeF,uObjSeed;
float hash(vec3 p){return fract(sin(dot(p,vec3(12.9898,78.233,37.719)))*43758.5453);}
float n3(vec3 p){vec3 i=floor(p),f=fract(p);
float n000=hash(i+vec3(0,0,0)), n100=hash(i+vec3(1,0,0));
float n010=hash(i+vec3(0,1,0)), n110=hash(i+vec3(1,1,0));
float n001=hash(i+vec3(0,0,1)), n101=hash(i+vec3(1,0,1));
float n011=hash(i+vec3(0,1,1)), n111=hash(i+vec3(1,1,1));
vec3 u=f*f*(3.0-2.0*f);
float n00=mix(n000,n100,u.x), n10=mix(n010,n110,u.x);
float n01=mix(n001,n101,u.x), n11=mix(n011,n111,u.x);
float n0=mix(n00,n10,u.y), n1=mix(n01,n11,u.y);
return mix(n0,n1,u.z);}
float fbm(vec3 p){float s=0.0,a=0.5;for(int i=0;i<5;i++){s+=a*n3(p);p*=2.02;a*=0.5;}return s;}
vec3 hsv2rgb(vec3 c){vec3 p=abs(fract(c.xxx+vec3(0.,0.6666667,0.3333333))*6.-3.);return c.z*mix(vec3(1.0),clamp(p-1.0,0.0,1.0),c.y);}
void main(){
  vec3 n=normalize(vNormal);
  vec3 V=vec3(0,0,1);
  vec3 L1=normalize(vec3(0.6,0.7,0.5)), L2=normalize(vec3(-0.4,0.65,-0.2));
  float ndl=max(dot(n,L1),0.0)*0.65 + max(dot(n,L2),0.0)*0.35;
  float rim=pow(1.0-max(dot(n,V),0.0),2.0);

  vec3 colA=uColorA, colB=uColorB, col;
  float t=uTime*(0.6+uSpeed);
  int m=int(floor(clamp(uModeF,0.0,10.0)+0.5));

  if(m==1){ // Glass / pearlescent
    float NoV = max(dot(n,V), 0.0);
    float baseThick = 0.14 + 0.05*sin(t*0.35 + uObjSeed*5.3);
    float micro = fbm(normalize(vPos)*5.0 + vec3(0.0,t*0.12,0.0) + vec3(uObjSeed*1.7));
    float thick = baseThick + 0.06*(micro - 0.5);
    float phase = thick * (1.6 + 1.1*NoV) * 6.28318530718;
    float hue = fract(phase*0.14);
    vec3 swirl = hsv2rgb(vec3(hue, 0.55, 1.0));
    float fres = pow(1.0 - NoV, 4.0);
    vec3 reflectCol = mix(vec3(0.98), swirl, 0.6);
    vec3 H1 = normalize(L1 + V), H2 = normalize(L2 + V);
    float spec = 0.18*pow(max(dot(n,H1),0.0), 80.0) + 0.15*pow(max(dot(n,H2),0.0), 80.0);
    vec3 shellTint = mix(vec3(1.0), swirl, 0.15);
    col = shellTint*0.03 + reflectCol * (0.02 + 0.06*ndl + 0.22*fres) + vec3(1.0)*spec + vec3(1.0)*rim*0.06;
  } else if(m==0){ // Marble
    float s=fbm(normalize(vPos)*3.2 + vec3(0.0,t*0.25+uPhase,0.0) + vec3(uObjSeed,uObjSeed*1.7,uObjSeed*2.3));
    float veins=sin((vPos.x+vPos.y+vPos.z)*8.0 + s*6.0 + uPhase + uObjSeed*3.14);
    float mm=smoothstep(-0.2,0.7,veins);
    vec3 base=mix(colA,colB,mm);
    col=base*(0.38+0.62*ndl) + vec3(1.0)*rim*0.12;
  } else if(m==2){ // Wireframe
    float k=9.0+2.0*fract(uObjSeed*7.0);
    vec3 q=normalize(vPos);
    float g=max(max(abs(sin(q.x*k)),abs(sin(q.y*k))),abs(sin(q.z*k)));
    float edge=smoothstep(0.92,0.985,g);
    vec3 base=mix(colA,colB,0.5)*(0.15+0.45*ndl);
    col=base + vec3(0.2,1.0,0.2)*edge*0.95 + vec3(1.0)*rim*0.12;
  } else if(m==3){ // Lava
    float f=fbm(normalize(vPos)*4.0 + vec3(0.0,t*0.7,0.0) + vec3(uObjSeed,uObjSeed*2.1,uObjSeed*3.3));
    float veins=smoothstep(0.55,0.8,f);
    vec3 hot=vec3(1.0,0.35,0.0), cool=vec3(0.05,0.02,0.02);
    col=mix(cool,hot,veins)*(0.38+0.62*ndl) + vec3(1.0)*rim*0.08;
  } else if(m==4){ // Toon
    float s=step(0.25,ndl)*0.45 + step(0.55,ndl)*0.3 + step(0.8,ndl)*0.25;
    vec3 base=mix(colA,colB,0.5);
    col=base*(0.24+s) + vec3(1.0)*step(0.8,rim)*0.18;
  } else if(m==5){ // Iridescent
    float h=fract(0.5+0.35*dot(normalize(vPos),vec3(0.3,0.8,0.5))+0.15*sin(t+uPhase+uObjSeed));
    vec3 iri=hsv2rgb(vec3(h,0.95,1.0));
    col=mix(iri,mix(colA,colB,0.4),0.25)*(0.32+0.68*ndl) + vec3(1.0)*rim*0.18;
  } else if(m==6){ // Spikes
    float s=fbm(normalize(vPos)*7.0 + vec3(0.0,t*1.25,0.0) + vec3(uObjSeed,uObjSeed*1.9,uObjSeed*2.7));
    float spike=smoothstep(0.62,0.90,s);
    vec3 base=mix(colA,colB,0.5);
    vec3 hi=base*1.8, lo=base*0.45;
    col=mix(lo,hi,spike)*(0.28+0.72*ndl) + vec3(1.0)*rim*0.14;
  } else if(m==7){ // Metallic
    float spec=pow(max(dot(normalize(vNormal),normalize(vec3(0.6,0.7,0.5)+vec3(-0.4,0.65,-0.2))),0.0),34.0);
    col=mix(colA,colB,0.5)*(0.22+0.60*ndl) + vec3(1.0)*spec*0.95 + vec3(1.0)*rim*0.12;
  } else if(m==8){ // Sky
    vec3 p=normalize(vPos);
    float ang=t*0.35+uPhase*0.3; mat2 R=mat2(cos(ang),-sin(ang),sin(ang),cos(ang));
    p.xy = vec3(R*vec2(p.x,p.y),0.0).xy;
    float base=fbm(p*3.0+vec3(uObjSeed*2.3,uObjSeed*1.1,uObjSeed*3.7));
    float puff=fbm(p*6.0+vec3(0.0,t*0.2,0.0)+vec3(uObjSeed*3.9));
    float clouds=smoothstep(0.55,0.85,base*0.6+puff*0.7);
    vec3 sky=vec3(0.53,0.75,0.98), cloud=vec3(1.0);
    vec3 baseCol=mix(sky,cloud,clouds);
    col=baseCol*(0.35+0.65*ndl) + vec3(1.0)*rim*0.12;
  } else if(m==9){ // Fireball orb: translucent, palette-colored shell
    vec3 base = mix(colA, colB, 0.35);
    col = base*(0.28+0.72*ndl) + vec3(1.0)*rim*0.08;
  } else {
    col=mix(colA,colB,0.5)*(0.38+0.62*ndl) + vec3(1.0)*rim*0.12;
  }
  gl_FragColor=vec4(clamp(col,0.0,1.0),uAlpha);
}`;

/* ---------- math / camera ---------- */
const NUCLEUS_R0=28, SHELL_STEP=22, ELECTRON_R=3.6, NUCLEON_R=2.7;
const v3=(x,y,z)=>[x,y,z], vadd=(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]];
const vmul=(a,s)=>[a[0]*s,a[1]*s,a[2]*s], vdot=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
const vcross=(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
const vlen=a=>Math.hypot(a[0],a[1],a[2]); const vnorm=a=>{const l=vlen(a)||1; return [a[0]/l,a[1]/l,a[2]/l];};
function rotateAroundAxis(p,u,ang){const c=Math.cos(ang),s=Math.sin(ang),dot=vdot(u,p),cross=vcross(u,p);return vadd(vadd(vmul(p,c),vmul(cross,s)),vmul(u,(1-c)*dot));}
function camBasis(yaw, pitch){
  const cy=Math.cos(yaw), sy=Math.sin(yaw);
  const cp=Math.cos(pitch), sp=Math.sin(pitch);
  const forward=[ sy*cp, sp, cy*cp ];
  const upW=[0,1,0];
  let right=[
    forward[1]*upW[2] - forward[2]*upW[1],
    forward[2]*upW[0] - forward[0]*upW[2],
    forward[0]*upW[1] - forward[1]*upW[0]
  ];
  const rl=Math.hypot(right[0],right[1],right[2])||1;
  right=[ right[0]/rl, right[1]/rl, right[2]/rl ];
  let up=[
    right[1]*forward[2] - right[2]*forward[1],
    right[2]*forward[0] - right[0]*forward[2]
  ];
  const ul=Math.hypot(up[0],up[1],up[2])||1;
  up=[ up[0]/ul, up[1]/ul, up[2]/ul ];
  return {forward,right,up};
}

/* ---------- color & diversity ---------- */
function prngFromHex(hex){
  const c=(hex||'').replace(/[^0-9a-fA-F]/g,''); let acc=0;
  for(let i=0;i<c.length;i+=2){ acc = (acc*131 + parseInt(c.substr(i,2),16))>>>0; }
  return XS32(acc||1);
}
function paletteFromBlock(height, hash, merkle){
  // Brighter palette, bigger separations, per-atom jitter
  const rng = XS32((height*2654435761)>>>0);
  const rHash = prngFromHex(hash||''); const rMerk = prngFromHex(merkle||'');

  const golden = 137.50776405003785;
  let baseHue = mod((height * golden) + rng()*180 + rHash()*60 - 30, 360);

  // large separations (~120Â° triadic/compl) + jitter
  const sepA = 120 + (rMerk()*30-15);   // Â±15Â°
  const sepB = 240 + (rHash()*40-20);   // Â±20Â°

  // Saturation and lightness tuned for vibrancy
  const sP = 0.88 + 0.10*rng(); const lP = 0.52 + 0.08*rMerk();
  const sN = 0.90 + 0.08*rng(); const lN = 0.50 + 0.10*rHash();
  const sE = 0.96;               const lE = 0.56 + 0.08*rng();
  const sS = 0.90;               const lS = 0.55 + 0.10*rng();

  // Assign hues (electrons get base, others spread around it)
  const hE = baseHue;
  const hP = mod(baseHue + sepA, 360);
  const hN = mod(baseHue + sepB, 360);

  // Shell/ring: contrast against electrons (complement w/ jitter)
  const hS = mod(hE + 180 + (rng()*40-20), 360);

  return {
    proton:  hslToRgb(hP/360, sP, lP),
    neutron: hslToRgb(hN/360, sN, lN),
    electron:hslToRgb(hE/360, sE, lE),
    shell:   hslToRgb(hS/360, sS, lS)
  };
}
function diversityFromBlock(b){
  const h=b.height|0, mr=b.merkle_root||'', id=b.id||b.hash||'';
  const rA=prngFromHex(mr), rB=prngFromHex(id);
  return {
    // biases for style families (0..1)
    famA: rA(), famB: rB(),
    // geometry/behavior jitter (small)
    orbitSpreadJ: 1.0 + (rB()*0.16 - 0.08),   // Â±8%
    eccBiasJ:     (rA()*0.18 - 0.09),         // Â±0.09 added pre-clamp
    sizeScaleJ:   1.0 + (rB()*0.20 - 0.10),   // Â±10%
    countJitter:  (byteAt(mr,5)%21)-10        // Â±10 electrons/protons jiggle
  };
}

/* ---------- mode picking with diversity (keeps sets distinct) ---------- */
const MODE_LIST=['Marble','Glass','Wireframe','Lava','Toon','Iridescent','Spikes','Metallic','Sky','Fireball'];
const FAMILY_BUCKETS = [
  [1,5,7],    // glossy / iridescent / metallic
  [3,6,9],    // aggressive: lava / spikes / fireball
  [0,2,4,8]   // stylized: marble / wireframe / toon / sky
];
function pickFromWeighted(bucket, bias){
  // rotate the bucket by bias to diversify
  const idx = Math.floor(mod(bias * (bucket.length+1), bucket.length));
  return bucket[idx];
}
function chooseSetModesFromBlock(b, diversity){
  const nonce=b.nonce||0, bits=b.bits||0, h=b.height|0;
  // weight families by biases; we pick different families for sets to force contrast
  const famOrder = [...FAMILY_BUCKETS];
  // simple shuffle seeded by height
  famOrder.sort((a,bk)=>((h+bits+nonce)%3)-1);

  const eFam = famOrder[0], pFam = famOrder[1], nFam = famOrder[2];
  const eMode = pickFromWeighted(eFam, diversity.famA);
  let pMode   = pickFromWeighted(pFam, diversity.famB*0.73 + 0.11);
  let nMode   = pickFromWeighted(nFam, diversity.famB*0.41 + diversity.famA*0.33);

  // Ensure distinctness (fallbacks)
  if(pMode===eMode){ pMode = pickFromWeighted(pFam, diversity.famB*0.29 + 0.37); }
  if(nMode===eMode || nMode===pMode){ nMode = pickFromWeighted(nFam, diversity.famA*0.61 + 0.23); }

  const sD=lastByte(b.id||b.hash||'');
  return { protons:pMode, neutrons:nMode, electrons:eMode, rings:(sD%3) };
}
const isPalindromeHeight = (h)=>{ const s=String(h); return s===s.split('').reverse().join(''); };

/* ---------- FireParticles (longer life, upward, translucent) ---------- */
class FireParticles{
  constructor(p, maxCount=900){
    this.p=p; this.max=maxCount;
    this.pos = new Array(this.max).fill(0).map(()=>[0,0,0]);
    this.vel = new Array(this.max).fill(0).map(()=>[0,0,0]);
    this.col = new Array(this.max).fill(0).map(()=>[255,150,40]);
    this.size= new Array(this.max).fill(0);
    this.life= new Array(this.max).fill(0);
    this.maxL= new Array(this.max).fill(0);
    this.idx=0;
  }
  spawn(x,y,z, nx,ny,nz, colorA, colorB){
    if(Math.random()>0.22) return;
    const worldUp = [0,-1,0]; // p5 WEBGL "up" is -Y
    const k=2;
    for(let i=0;i<k;i++){
      const id = this.idx; this.idx=(this.idx+1)%this.max;
      const jitterX = (Math.random()-0.5)*1.8;
      const jitterZ = (Math.random()-0.5)*1.8;
      const vx = nx*5 + jitterX + 0.5*worldUp[0];
      const vy = ny*5 + 7 + Math.random()*1.8 + 0.6*worldUp[1];
      const vz = nz*5 + jitterZ + 0.5*worldUp[2];
      const t = Math.random()*0.5 + 0.25;
      const base = [
        Math.round(colorA[0]*(1-t)+colorB[0]*t),
        Math.round(colorA[1]*(1-t)+colorB[1]*t),
        Math.round(colorA[2]*(1-t)+colorB[2]*t),
      ];
      this.pos[id][0]=x; this.pos[id][1]=y; this.pos[id][2]=z;
      this.vel[id][0]=vx; this.vel[id][1]=vy; this.vel[id][2]=vz;
      this.col[id]=base;
      this.size[id]=1.8+Math.random()*1.8;
      this.maxL[id]=1.4+Math.random()*0.8;
      this.life[id]=this.maxL[id];
    }
  }
  update(dt){
    for(let i=0;i<this.max;i++){
      const L=this.life[i]; if(L<=0) continue;
      this.vel[i][1] -= 9.0*dt;
      this.vel[i][0]*= (1.0-0.8*dt);
      this.vel[i][1]*= (1.0-0.22*dt);
      this.vel[i][2]*= (1.0-0.8*dt);
      this.vel[i][0] += (Math.sin((this.pos[i][2]+this.pos[i][1])*0.08)*1.6)*dt;
      this.vel[i][2] += (Math.cos((this.pos[i][0]+this.pos[i][1])*0.08)*1.6)*dt;
      this.pos[i][0]+=this.vel[i][0]*dt;
      this.pos[i][1]+=this.vel[i][1]*dt;
      this.pos[i][2]+=this.vel[i][2]*dt;
      this.size[i] *= (1.0 + 0.42*dt);
      this.life[i]-=dt*0.6;
    }
  }
  draw(){
    const p=this.p;
    const gl = p._renderer.GL;
    p.push();
    p.noStroke();
    p.blendMode(p.ADD);
    gl.depthMask(false);
    for(let i=0;i<this.max;i++){
      const L=this.life[i]; if(L<=0) continue;
      const age = 1.0 - (L/this.maxL[i]);
      const a = Math.max(0, Math.min(1, L/this.maxL[i]));
      const c = this.col[i];
      const bright = [
        Math.round(c[0]*(1-0.35*age) + 255*(0.35*age)),
        Math.round(c[1]*(1-0.35*age) + 255*(0.35*age)),
        Math.round(c[2]*(1-0.35*age) + 255*(0.35*age)),
      ];
      p.push();
      p.translate(this.pos[i][0], this.pos[i][1], this.pos[i][2]);
      p.fill(bright[0], bright[1], bright[2], Math.round(140*a));
      p.sphere(Math.max(0.9, this.size[i]*0.55), 8, 6);
      p.pop();
    }
    gl.depthMask(true);
    p.blendMode(p.BLEND);
    p.pop();
  }
}

/* ---------- build atom ---------- */
function buildAtomFromBlock(b){
  const height=b.height, txCount=(b.tx_count!=null?b.tx_count:1), timestamp=(b.timestamp!=null?b.timestamp:0);
  const bits=(b.bits!=null?b.bits:0), nonce=(b.nonce!=null?b.nonce:0), merkleRoot=(b.merkle_root||""), weight=(b.weight!=null?b.weight:0), size=(b.size!=null?b.size:0), version=(b.version!=null?b.version:0), hash=(b.id||b.hash||"");

  const diversity = diversityFromBlock(b);
  const colors=paletteFromBlock(height, hash, merkleRoot);

  // counts with slightly wider jitter (seeded)
  const baseE=(height%118)+1, eJitter=((byteAt(hash,5)%64)-32) + diversity.countJitter;
  const electrons=clamp(baseE+eJitter, 6, 200);

  const protonBias=((byteAt(merkleRoot,9)%37)-18); // was Â±15 â†’ now Â±18
  const Z=clamp(baseE+protonBias, 6, 180);

  const neutronSkew=((byteAt(hash,2)%121)-60)/170; // slightly wider skew range
  const N=clamp(Math.round(Z*(1.0+neutronSkew)) + (hexByteSum(merkleRoot)%23)-11, 6, 240);

  const shells=fillShells(electrons);
  const prod=Math.max(1, txCount*Math.max(1,size)); const lg=Math.log10(prod);
  const speedScale=clamp((lg-8.6)/(10.7-8.6)*(2.2-0.55)+0.55, 0.55, 2.2);

  const dens=clamp(weight/Math.max(1,size*4),0.6,1.4);
  const tightness=clamp((dens*0.75)+(1.15-0.55*0.25), 0.6,1.4);

  let eccGlobal=clamp(0.3 + ((version&0xf)/16)*0.5 + ((nonce&0x3f)/63)*0.2 + diversity.eccBiasJ, 0.08,0.92);

  const orbitSpread=(1.0+((version&0xf)-7.5)*0.01) * diversity.orbitSpreadJ;
  const radii=shells.map((_,i)=>(NUCLEUS_R0*1.3+SHELL_STEP*(i+1))*orbitSpread);

  // rings: use paletteFromBlock shell color; also keep old slight hue shift by last byte
  const hashLast=lastByte(hash);
  const ringThick=1.0, ringAlpha=230;
  const ringColor=shiftHue(colors.shell, (hashLast/255-0.5)*24);

  const electronAngles=[], eMeta=[];
  for(let i=0;i<shells.length;i++){ electronAngles[i]=[]; eMeta[i]=[];
    for(let j=0;j<shells[i];j++){
      const b0=byteAt(merkleRoot,(i*31+j*11+1)), b1=byteAt(hash,(i*17+j*7+5)), b2=byteAt(merkleRoot,(i*53+j*13+9));
      const seed=(b0<<16)^(b1<<8)^b2; let u=vnorm(v3((b0/255)-0.5,(b1/255)-0.5,(b2/255)-0.5)); if(vlen(u)<1e-6) u=[0,0,1];
      const ref=Math.abs(u[2])<0.9?[0,0,1]:[1,0,0]; let v=vnorm(vcross(u,ref)), w=vcross(u,v);
      const e=clamp(eccGlobal*(0.6+0.8*(b1/255)),0.05,0.93), pre=(0.05+0.45*(b2/255))*speedScale, phase=(b0/255)*Math.PI*2;
      const rosK=1+(seed%3), rosAmp=0.03+0.05*(b1/255), spMul=(0.6+0.8*(b0/255));
      const hueOffset=( (i*97 + j*131 + seed) % 360 ); const objSeed=(seed%1000)/1000;
      electronAngles[i][j]=(b2/255)*Math.PI*2; eMeta[i][j]={u,v,w,e,pre,phase,rosK,rosAmp,spMul,hueOffset,objSeed};
    } }
  const base=(timestamp%600)/600, noiseSeed=(nonce%997)/997;
  const speeds=shells.map((_,i)=> (0.004+0.015*((Math.sin((base+i*0.137+noiseSeed)*43758.5453)*0.5+0.5)))*speedScale);

  const totalNuc=Math.min(900,Z+N), nucleusPoints=[]; for(let i=0;i<totalNuc;i++){
    const rNorm=Math.pow(Math.random(), tightness);
    const r=NUCLEUS_R0*(0.35+0.65*rNorm), th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
    const isProton = i<Z; const hueOffset = (i*23 + (isProton?177:311)) % 360; const objSeed = ((i*101 + (isProton?37:73)) % 997)/997;
    nucleusPoints.push({x:r*Math.sin(ph)*Math.cos(th),y:r*Math.sin(ph)*Math.sin(th),z:r*Math.cos(ph),isProton,hueOffset,objSeed});
  }

  // shaders & styles
  const animAmp=0.35, animSpeed=0.9; const blockPhase=(byteAt(merkleRoot,7)/255)*Math.PI*2;
  const isPearl170 = height===170;
  const is1337  = height===1337;
  const halving = (!isPearl170) && (height>0 && height%210000===0);
  const palindrome = isPalindromeHeight(height);

  const baseSet = chooseSetModesFromBlock(b, diversity);

  return { block:b,height,Z,N,electrons,shells,radii,speeds,electronAngles,eMeta,nucleusPoints,colors,
    shader:{amp:animAmp,speed:animSpeed,blockPhase},
    setModes: baseSet,
    style:{ eSizeScale:clamp((1.0*diversity.sizeScaleJ) * ((((b.weight||b.size*4)-2.8e6)/(4.0e6-2.8e6))*(1.50-0.90)+0.90),0.7,2.0),
      ringThick, ringAlpha, ringColor, halving, pearl170:isPearl170, is1337, palindrome,
      nucleusTight: tightness } };
}

/* ---------- panels ---------- */
function injectPanels(atom){
  const det=document.getElementById('blockPanel'); det.innerHTML='';
  const sum=document.createElement('summary');
  const sLeft=document.createElement('span'); sLeft.textContent='â–¼ Block Details';
  const sRight=document.createElement('span'); sRight.style.color='#d7ecff'; sRight.style.fontWeight='500';
  const blk=atom.block; sRight.textContent = '#' + blk.height + ' â€” ' + shortHash(blk.id||blk.hash);
  sum.appendChild(sLeft); sum.appendChild(sRight); det.appendChild(sum);

  const body=document.createElement('div'); body.id='blkBody';
  const chips=document.createElement('div'); chips.style.marginBottom='6px';
  [['Electrons',atom.electrons],['Protons',atom.Z],['Neutrons',atom.N]].forEach(([k,v])=>{const c=document.createElement('span'); c.className='chip'; c.textContent=`${k}: ${v}`; chips.appendChild(c);});
  if(atom.style.pearl170){ const c=document.createElement('span'); c.className='chip'; c.textContent='ðŸ«§ #170 Pearlescent'; chips.appendChild(c); }
  else if(atom.style.is1337){ const c=document.createElement('span'); c.className='chip'; c.textContent='ðŸŸ© 1337 Neon'; chips.appendChild(c); }
  else if(atom.style.halving){ const c=document.createElement('span'); c.className='chip'; c.textContent='Halving Mode'; chips.appendChild(c); }
  if(atom.style.palindrome){ const c=document.createElement('span'); c.className='chip'; c.textContent='â†” Palindromic Ping-Pong'; chips.appendChild(c); }
  body.appendChild(chips);

  const tbl=document.createElement('table');
  const rows=[
    ['Tx count', (blk.tx_count!=null?blk.tx_count:'n/a')],
    ['Size (bytes)', (blk.size!=null?blk.size:'n/a')],
    ['Weight (WU)', (blk.weight!=null?blk.weight:'n/a')],
    ['Version', (blk.version!=null?blk.version:'n/a')],
    ['Bits', (blk.bits!=null?blk.bits:'n/a')],
    ['Nonce', (blk.nonce!=null?blk.nonce:'n/a')],
    ['Time', (blk.timestamp? new Date(blk.timestamp*1000).toLocaleString():'n/a')],
    ['Merkle root', shortHash(blk.merkle_root)]
  ];
  rows.forEach(([k,v])=>{ const tr=document.createElement('tr'); const td1=document.createElement('td'); td1.textContent=k; const td2=document.createElement('td');
    if(k==='Merkle root'){ const code=document.createElement('code'); code.textContent=String(v); td2.appendChild(code);} else td2.textContent=String(v);
    tr.appendChild(td1); tr.appendChild(td2); tbl.appendChild(tr); });
  body.appendChild(tbl); det.appendChild(body);

  const info=document.getElementById('infoPanel'); info.innerHTML='';
  const s2=document.createElement('summary'); const badge=document.createElement('span'); badge.className='badge'; badge.textContent='?';
  s2.appendChild(badge); s2.appendChild(document.createTextNode(' Info / How it works')); info.appendChild(s2);
  const ib=document.createElement('div'); ib.style.padding='10px 12px';
  ib.innerHTML='<h3>Controls</h3><p>Rotate: drag / 1-finger â€¢ Pan: right-drag / 2-finger â€¢ Zoom: wheel / pinch â€¢ Toggle UI: <b>E</b> / <b>double-tap</b></p>';
  info.appendChild(ib);
  det.open=false; info.open=false;
}

/* ---------- p5 + inputs + draw ---------- */
let p5Instance=null, orbShader=null, shaderLinked=false;
let camDist=560, camYaw=0.2, camPitch=-0.1, camTarget=[0,0,0];
let minCamDist=140, maxCamDist=20000;
let lastX=0, lastY=0, dragButton=0;
let pinchPrev=null, twoPrevMid=null, lastTapTime=0, lastTapXY=[0,0];
let interactionMode='none';
let modelSpin = 0;

// âœ… Replace the second "const MODE_LIST = [...]" with this:
if (!('MODE_LIST' in window)) {
  window.MODE_LIST = ['Marble','Glass','Wireframe','Lava','Toon','Iridescent','Spikes','Metallic','Sky','Fireball'];
}

let overrides = { proton:null, neutron:null, electron:null };
function populateSelectors(){
  const opts = MODE_LIST.map((n,i)=>`<option value="${i}">${n}</option>`).join('');
  selProton.innerHTML = `<option value="">Auto</option>${opts}`;
  selNeutron.innerHTML = `<option value="">Auto</option>${opts}`;
  selElectron.innerHTML = `<option value="">Auto</option>${opts}`;
}
populateSelectors();
selProton.onchange = e => { overrides.proton   = (e.target.value===''?null:Number(e.target.value)); };
selNeutron.onchange= e => { overrides.neutron  = (e.target.value===''?null:Number(e.target.value)); };
selElectron.onchange= e => { overrides.electron = (e.target.value===''?null:Number(e.target.value)); };

function startSketch(blk){
  if(p5Instance){ p5Instance.remove(); p5Instance=null; }

  camDist=560; camYaw=0.2; camPitch=-0.1; camTarget=[0,0,0];
  modelSpin = 0; interactionMode='none';

  const atom=buildAtomFromBlock(blk);
  injectPanels(atom);

  // palindrome helpers
  const eDir=[], eTurns=[];
  for(let i=0;i<atom.shells.length;i++){
    eDir[i]=[]; eTurns[i]=[];
    for(let j=0;j<atom.shells[i];j++){ eDir[i][j]=1; eTurns[i][j]=Math.floor(atom.electronAngles[i][j]/TAU); }
  }
  atom._eDir = eDir; atom._eTurns = eTurns;

  const largestRadius = atom.radii.length ? atom.radii[atom.radii.length-1] : 140;
  minCamDist = Math.max( largestRadius * 1.2, 90 );
  maxCamDist = 30000;
  const maxPan = Math.max(200, largestRadius * 2.2);

  // perf-aware detail
  const totalElectrons = atom.electrons;
  const totalNucleons  = Math.min(900, atom.Z + atom.N);
  function detailFor(count, baseU, baseV){
    if(count > 400) return [Math.max(12, baseU-36), Math.max(8, baseV-24)];
    if(count > 200) return [Math.max(16, baseU-28), Math.max(10, baseV-18)];
    if(count > 120) return [Math.max(20, baseU-18), Math.max(14, baseV-12)];
    if(count > 60 ) return [Math.max(24, baseU-10), Math.max(16, baseV-8)];
    return [baseU, baseV];
  }
  let electronDetail = detailFor(totalElectrons, 52, 36);
  let nucleonDetail  = detailFor(totalNucleons,  44, 30);
  if(atom.style.pearl170){ electronDetail=[22,16]; nucleonDetail=[20,14]; }

  function clampCamTarget(){
    const L = Math.hypot(camTarget[0],camTarget[1],camTarget[2]);
    const lim = maxPan;
    if(!Number.isFinite(L) || L>lim){
      const s = Number.isFinite(L)&&L>0 ? (lim/L) : 0;
      camTarget[0]*=s; camTarget[1]*=s; camTarget[2]*=s;
    }
    if(!isFiniteVec(camTarget)) camTarget=[0,0,0];
  }

  // --- Fire particle system (global to this sketch) ---
  let fire = new FireParticles(p5.prototype, 900);

  const sketch=(p)=>{
    p.setup=()=>{
      const cnv=p.createCanvas(p.windowWidth,p.windowHeight,p.WEBGL);
      cnv.canvas.classList.add('p5canvas');
      cnv.canvas.addEventListener('contextmenu', e=>e.preventDefault());
      cnv.canvas.addEventListener('auxclick',  e=>e.preventDefault());
      p.setAttributes('alpha', false);
      p.setAttributes('antialias', true);

      try{ orbShader=p.createShader(VERT,FRAG); shaderLinked=true; }
      catch(e){ orbShader=null; shaderLinked=false; console.warn('Shader creation failed:',e); }

      p.ambientLight(120); p.directionalLight(255,255,255,0.5,0.6,0.4);

      // bind fire system to real renderer p5 instance
      fire = new FireParticles(p, 900);

      const canvasEl = cnv.canvas;
      if(canvasEl){
        canvasEl.addEventListener('touchstart',(e)=>{
          if(e.touches.length===1){
            interactionMode='rotate';
            const t=e.touches[0]; const now=performance.now();
            const dist=Math.hypot(t.clientX-lastTapXY[0], t.clientY-lastTapXY[1]);
            if(now-lastTapTime<280 && dist<12){ $('#uiRoot').classList.toggle('show'); lastTapTime=0; }
            else { lastTapTime=now; lastTapXY=[t.clientX,t.clientY]; }
            lastX=t.clientX; lastY=t.clientY;
          } else if(e.touches.length===2){
            interactionMode='panzoom';
            const t0=e.touches[0], t1=e.touches[1];
            pinchPrev=Math.max(1, Math.hypot(t0.clientX-t1.clientX, t0.clientY-t1.clientY));
            twoPrevMid=[(t0.clientX+t1.clientX)/2, (t0.clientY+t1.clientY)/2];
          }
          e.preventDefault();
        }, {passive:false});

        canvasEl.addEventListener('touchmove',(e)=>{
          if(interactionMode==='rotate' && e.touches.length===1){
            const t=e.touches[0], dx=t.clientX-lastX, dy=t.clientY-lastY; lastX=t.clientX; lastY=t.clientY;
            camYaw+=dx*0.005; camPitch=clamp(camPitch+dy*0.005,-Math.PI/2+0.02,Math.PI/2-0.02);
          } else if(interactionMode==='panzoom' && e.touches.length===2){
            const t0=e.touches[0], t1=e.touches[1];
            let d=Math.hypot(t0.clientX-t1.clientX, t0.clientY-t1.clientY); d=Math.max(1,d);
            if(pinchPrev==null) pinchPrev=d;
            const rawScale = d / pinchPrev;
            const saneScale = isFinite(rawScale) ? clamp(rawScale, 0.2, 5.0) : 1.0;
            const next = camDist / Math.pow(saneScale, 0.85);
            const limited = clamp(next, camDist*0.6, camDist*1.6);
            camDist = clamp(limited, minCamDist, maxCamDist);
            pinchPrev = d;

            const midX=(t0.clientX+t1.clientX)/2, midY=(t0.clientY+t1.clientY)/2;
            if(twoPrevMid){
              const dx = midX - twoPrevMid[0]; const dy = midY - twoPrevMid[1];
              const {right, up} = camBasis(camYaw, camPitch);
              const panScale = (camDist * Math.tan(p.radians(55) * 0.5)) * 1.5 / p.height;
              const add=[ ( dx * panScale) * right[0] + (-dy * panScale) * up[0],
                          ( dx * panScale) * right[1] + (-dy * panScale) * up[1],
                          ( dx * panScale) * right[2] + (-dy * panScale) * up[2] ];
              camTarget[0]+=add[0]; camTarget[1]+=add[1]; camTarget[2]+=add[2];
              clampCamTarget();
            }
            twoPrevMid=[midX,midY];
          }
          e.preventDefault();
        }, {passive:false});

        canvasEl.addEventListener('touchend',()=>{ interactionMode='none'; pinchPrev=null; twoPrevMid=null; }, {passive:true});
      }
    };

    p.windowResized=()=>{ p.resizeCanvas(p.windowWidth,p.windowHeight); };

    p.mousePressed=(e)=>{ lastX=p.mouseX; lastY=p.mouseY; dragButton=p.mouseButton; interactionMode = (dragButton===p.RIGHT)?'panzoom':'rotate'; };
    p.mouseReleased=()=>{ interactionMode='none'; };
    p.mouseDragged=()=>{
      const dx=p.mouseX-lastX, dy=p.mouseY-lastY; lastX=p.mouseX; lastY=p.mouseY;
      if(interactionMode==='rotate'){
        camYaw+=dx*0.005; camPitch=clamp(camPitch+dy*0.005,-Math.PI/2+0.02,Math.PI/2-0.02);
      } else if(interactionMode==='panzoom'){
        const {right, up} = camBasis(camYaw, camPitch);
        const panScale = (camDist * Math.tan(p.radians(55) * 0.5)) * 1.5 / p.height;
        const add=[ ( dx * panScale) * right[0] + (-dy * panScale) * up[0],
                    ( dx * panScale) * right[1] + (-dy * panScale) * up[1],
                    ( dx * panScale) * right[2] + (-dy * panScale) * up[2] ];
        camTarget[0]+=add[0]; camTarget[1]+=add[1]; camTarget[2]+=add[2];
        if(!isFiniteVec(add) || !isFiniteVec(camTarget)){ camTarget=[0,0,0]; }
        clampCamTarget();
      }
    };
    p.mouseWheel=(e)=>{
      const s = Math.exp(e.deltaY * 0.0012);
      camDist = clamp(camDist * s, minCamDist, maxCamDist);
      e.preventDefault();
    };

    function drawOrbMat(cA,cB,r,t,alpha,mode,seed,detail){
      const m=Math.max(0,Math.min(10,(mode|0)));
      const a = (m===1) ? (alpha * 0.12)     // Glass: very thin
              : (m===9) ? (alpha * 0.55)     // Fireball: translucent shell
              :           alpha;

      if(orbShader && shaderLinked){
        try{
          p.noStroke(); p.shader(orbShader);
          orbShader.setUniform('uColorA', cA.map(v=>v/255));
          orbShader.setUniform('uColorB', cB.map(v=>v/255));
          orbShader.setUniform('uTime', t);
          orbShader.setUniform('uAlpha', a);
          orbShader.setUniform('uModeF', m*1.0);
          orbShader.setUniform('uPhase', atom.shader.blockPhase||0.0);
          orbShader.setUniform('uAmp', atom.shader.amp||0.25);
          orbShader.setUniform('uSpeed', atom.shader.speed||0.9);
          orbShader.setUniform('uObjSeed', seed||0.0);
          p.sphere(r, detail[0], detail[1]);
          p.resetShader();
          return;
        }catch(e){
          console.warn('Shader draw error â€” fallback:',e);
          shaderLinked=false; orbShader=null;
        }
      }

      // Fallback
      p.resetShader(); p.noStroke();
      p.ambientLight(90);
      p.directionalLight(230,230,230, 0.6,0.7,0.5);
      p.ambientMaterial(cA[0], cA[1], cA[2], Math.round(255*a));
      p.specularMaterial(60,60,60);
      p.shininess(12);
      p.sphere(r, Math.max(16, detail[0]-8), Math.max(10, detail[1]-6));
    }

    function drawRings(t){
      p.push();
      for(let i=0;i<atom.shells.length;i++){
        const r=atom.radii[i];
        let col = atom.style.ringColor.slice();
        let alpha = atom.style.ringAlpha, thick = atom.style.ringThick;
        if(atom.style.is1337){
          col = [60,255,130]; alpha=255; thick=1.4;
        } else if(atom.style.halving){
          const pulse = 0.5 + 0.5*Math.sin(t*2.0);
          col = mixRGB([212,172,55],[255,220,120], 0.65);
          alpha = Math.round(170 + 70*pulse);
          thick = 1.0 + 0.6*pulse;
        } else if(atom.style.pearl170){
          col = [255,198,120]; alpha=230; thick=1.2;
        }
        p.noFill();
        p.stroke(col[0],col[1],col[2],alpha);
        p.strokeWeight(thick);
        p.circle(0,0,r*2);
      }
      p.pop();
    }

    // fire emit helper
    function emitFireAt(x,y,z, nx,ny,nz, cA, cB, isFire){
      if(!isFire) return;
      fire.spawn(x,y,z, nx,ny,nz, cA, cB);
    }

    function drawNucleus(t){
      let protonMode  = (overrides.proton  ?? atom.setModes.protons);
      let neutronMode = (overrides.neutron ?? atom.setModes.neutrons);

      // Make nucleons visually related to electrons but notably distinct (offset hues)
      let cP_A = shiftHue(atom.colors.electron, -35), cP_B = shiftHue(atom.colors.electron, -5);
      let cN_A = shiftHue(atom.colors.electron, +45),  cN_B = shiftHue(atom.colors.electron, +75);

      if(atom.style.is1337){
        protonMode = 2; neutronMode = 2;
        cP_A = [255,255,60]; cP_B = [255,255,60];
        cN_A = [255,160,40]; cN_B = [255,160,40];
      }

      let sizePulse = 1.0;
      let drawSoftGlow = false;
      if(atom.style.halving){
        protonMode = 7; neutronMode = 7;
        cP_A = [212,172,55]; cP_B = [255,220,120];
        cN_A = [212,172,55]; cN_B = [255,220,120];
        sizePulse = 1.0 + 0.05*Math.sin(t*2.0);
        drawSoftGlow = true;
      }

      if(atom.style.pearl170){
        protonMode  = 1; neutronMode = 1;
        cP_A = [245,245,255]; cP_B = [235,235,255];
        cN_A = [250,240,255]; cN_B = [235,235,250];
      }

      // Soft translucent glow for halving
      if(drawSoftGlow){
        const gl = p._renderer.GL;
        p.push(); p.noStroke(); p.blendMode(p.ADD); gl.depthMask(false);
        const layers = 5;
        for(let i=0;i<layers;i++){
          const k = (i+1)/layers;
          const rad = NUCLEUS_R0 * (1.05 + 0.55*k);
          const al  = Math.round(28 * (1.0 - k));
          p.fill(255, 200, 90, al);
          p.sphere(rad, 20, 14);
        }
        gl.depthMask(true); p.blendMode(p.BLEND); p.pop();
      }

      for(const q of atom.nucleusPoints){
        p.push();
        let x=q.x, y=q.y, z=q.z;
        if(atom.style.pearl170){
          const swirl = 0.35 * Math.sin(t*0.6 + q.objSeed*6.28);
          const cs=Math.cos(swirl), sn=Math.sin(swirl);
          const rx = x*cs - z*sn, rz = x*sn + z*cs;
          const breathe = 1.0 + 0.06*Math.sin(t*1.3 + q.objSeed*4.0 + (q.isProton?0.0:1.2));
          x=rx*breathe; y=y*breathe; z=rz*breathe;
        }
        p.translate(x,y,z);
        const nx = x/(vlen([x,y,z])||1), ny = y/(vlen([x,y,z])||1), nz = z/(vlen([x,y,z])||1);

        const isFireP = (overrides.proton ?? atom.setModes.protons)===9;
        const isFireN = (overrides.neutron?? atom.setModes.neutrons)===9;

        if(q.isProton){
          drawOrbMat(cP_A,cP_B,NUCLEON_R*sizePulse,t,1.0,protonMode,q.objSeed, nucleonDetail);
          emitFireAt(x,y,z, nx,ny,nz, cP_A,cP_B, isFireP);
        }else{
          drawOrbMat(cN_A,cN_B,NUCLEON_R*sizePulse,t,1.0,neutronMode,q.objSeed, nucleonDetail);
          emitFireAt(x,y,z, nx,ny,nz, cN_A,cN_B, isFireN);
        }
        p.pop();
      }
    }

    function drawElectrons(t){
      let eMode = (overrides.electron ?? atom.setModes.electrons);
      let sizeScale = atom.style.eSizeScale;
      let baseColA = atom.colors.electron, baseColB = atom.style.ringColor;

      if(atom.style.is1337){
        eMode = 2; baseColA = [60,255,130]; baseColB = [60,255,130];
      }
      if(atom.style.halving){
        eMode = 7; baseColA = [210,215,220]; baseColB = [240,245,250];
        sizeScale *= 1.0 + 0.08*Math.sin(t*2.0);
      }
      if(atom.style.pearl170){
        eMode = 1; baseColA=[245,245,255]; baseColB=[230,235,255];
      }

      const isFireE = (overrides.electron ?? atom.setModes.electrons)===9;

      for(let i=0;i<atom.shells.length;i++){
        const r=atom.radii[i], baseSpeed=atom.speeds[i];
        for(let j=0;j<atom.shells[i];j++){
          const m=atom.eMeta[i][j]; let th=atom.electronAngles[i][j];
          let a=r*(1+m.e*0.35), b=r*(1-m.e*0.35);
          let pre=t*m.pre + m.phase;

          if(atom.style.pearl170){
            a *= 1.0 + 0.06*Math.sin(t*0.9 + m.objSeed*3.0);
            b *= 1.0 + 0.06*Math.cos(t*1.1 + m.objSeed*4.1);
            pre *= 0.8;
          }

          const v=rotateAroundAxis(m.v,m.u,pre), w=rotateAroundAxis(m.w,m.u,pre);
          const basePt=vadd(vmul(v,a*Math.cos(th*1.0)), vmul(w,b*Math.sin(th*1.3)));
          const wob=1.0 + m.rosAmp*Math.sin(th*m.rosK + m.phase*0.7);
          const pt=vmul(basePt, wob);

          const mixT=((j%7)/7)*0.35;
          const cA=mixRGB(baseColA, baseColB, mixT);
          const cB=baseColB;

          p.push(); p.translate(pt[0],pt[1],pt[2]);
          drawOrbMat(cA, cB, ELECTRON_R*sizeScale, t, 1.0, eMode, m.objSeed, electronDetail);
          p.pop();

          const R = Math.hypot(pt[0],pt[1],pt[2])||1;
          emitFireAt(pt[0],pt[1],pt[2], pt[0]/R,pt[1]/R,pt[2]/R, cA,cB, isFireE);

          const dir = (atom.style.palindrome ? atom._eDir[i][j] : 1);
          const delta = baseSpeed*m.spMul*dir;
          const nextAngle = atom.electronAngles[i][j] + delta;
          atom.electronAngles[i][j] = nextAngle;

          if(atom.style.palindrome){
            const prevTurns = atom._eTurns[i][j];
            const newTurns = Math.floor(nextAngle/TAU);
            if(newTurns > prevTurns){ atom._eDir[i][j] = -atom._eDir[i][j]; }
            atom._eTurns[i][j] = newTurns;
          }
        }
      }
    }

    p.draw=()=>{
      const t=p.millis()*0.001;
      const dt=Math.max(0.001, Math.min(0.05, p.deltaTime/1000));

      // Background
      if(atom.style.halving){
        const k = 0.5 + 0.5*Math.sin(t*1.6);
        const bg = mixRGB([10,4,0],[255,120,20], k);
        p.background(bg[0],bg[1],bg[2]);
      } else {
        p.background(0);
      }

      // Camera
      const fovy=p.radians(55), aspect=p.width/p.height, near=0.1, far=30000;
      p.perspective(fovy,aspect,near,far);
      const cx=camTarget[0]+camDist*Math.cos(camPitch)*Math.sin(camYaw);
      const cy=camTarget[1]+camDist*Math.sin(camPitch);
      const cz=camTarget[2]+camDist*Math.cos(camPitch)*Math.cos(camYaw);
      if(![cx,cy,cz].every(Number.isFinite)){ camTarget=[0,0,0]; }
      p.camera(cx,cy,cz, camTarget[0],camTarget[1],camTarget[2], 0,1,0);

      // coin-spin
      modelSpin += 0.16 * dt;
      p.push(); p.rotateY(modelSpin);

      drawRings(t);
      drawNucleus(t);
      drawElectrons(t);

      // update + draw fire particles
      fire.update(dt);
      fire.draw();

      p.pop();
    };
  };

  const container=document.createElement('div'); container.style.position='fixed'; container.style.inset='0'; container.style.zIndex='1'; document.body.appendChild(container);
  p5Instance=new p5(sketch, container);
}

/* ---------- networking / buttons / boot ---------- */
const API='https://mempool.space/api';
async function fetchText(u){const r=await fetch(u); if(!r.ok) throw new Error(r.status+' '+u); return (await r.text()).trim();}
async function fetchJSON(u){const r=await fetch(u); if(!r.ok) throw new Error(r.status+' '+u); return r.json();}

const progress = $('#progress');
function showProgress(msg){ progress.style.display='block'; progress.textContent=msg; }
function hideProgress(){ progress.style.display='none'; }

async function loadBlockByHeight(height){
  try{
    showProgress('Resolving block '+height+'â€¦');
    const hash=await fetchText(API+'/block-height/'+height);
    showProgress('Fetching headerâ€¦');
    const blk=await fetchJSON(API+'/block/'+hash);
    hideProgress();
    selProton.value=''; selNeutron.value=''; selElectron.value=''; overrides={proton:null,neutron:null,electron:null};
    startSketch(blk);
  }catch(e){ showProgress('Error: '+e.message); }
}
async function loadLatest(){
  try{
    showProgress('Getting tip heightâ€¦');
    const h=await fetchText(API+'/blocks/tip/height');
    heightInput.value=h; await loadBlockByHeight(h);
  }catch(e){ showProgress('Error: '+e.message+'\nTry entering a known height (e.g. 840000) and press Load.'); }
}

loadBtn.onclick=async()=>{const h=Number(heightInput.value); if(!h){alert('Enter a block height'); return;} try{ await loadBlockByHeight(h);}catch(e){ showProgress('Error: '+e.message); }};
latestBtn.onclick=async()=>{ try{ await loadLatest(); }catch(e){ showProgress('Error: '+e.message); }};
resetBtn.onclick=()=>{ camDist=Math.max(minCamDist*1.6,560); camYaw=0.2; camPitch=-0.1; camTarget=[0,0,0]; modelSpin=0; interactionMode='none'; };

document.addEventListener('keydown',e=>{ if(e.key==='e'||e.key==='E') document.getElementById('uiRoot').classList.toggle('show'); });
setTimeout(()=>document.getElementById('hint').classList.add('hide'),15000);
// new44
// Boot
loadLatest();
</script>
</body>
</html>
