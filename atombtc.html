<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Bitcoin Block Atom — full build (mobile-friendly + styles)</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='8' fill='%2300c2ff'/%3E%3C/svg%3E">
<style>
  :root{--panel:rgba(10,14,18,0.92);--border:#1e2a33;--text:#d9ecff;--muted:#9cc6eb}
  html,body{margin:0;height:100%;background:#000;color:var(--text);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  canvas{display:block;touch-action:none}
  /* HUD */
  .hud{position:fixed;z-index:20;left:12px;right:12px;top:12px;background:var(--panel);border:1px solid var(--border);
       border-radius:14px;padding:10px;backdrop-filter:blur(6px);display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .hud input,.hud button,.hud select{font:inherit;border-radius:10px;border:1px solid var(--border);background:#121820;color:var(--text);padding:8px 10px}
  .hud label{opacity:.9}
  .btn{cursor:pointer}
  .panel{position:fixed;z-index:12;background:var(--panel);border:1px solid var(--border);border-radius:14px;color:#cfe4ff;
         padding:10px 12px;max-width:min(520px,calc(100vw-24px));backdrop-filter:blur(6px);font-size:14px}
  #legend{left:12px;top:100px}
  details#infoPanel{left:12px;bottom:12px}
  details#blockPanel{right:12px;bottom:12px}
  details summary{cursor:pointer;list-style:none;display:flex;align-items:center;gap:8px}
  details summary::-webkit-details-marker{display:none}
  .badge{width:24px;height:24px;display:grid;place-items:center;border-radius:999px;background:#1e2a33;border:1px solid #2b3a44}
  .chip{display:inline-block;padding:2px 6px;border:1px solid #2b3a44;border-radius:8px;margin:2px;color:#d7ecff;font-size:12px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:14px;padding:8px 12px;background:#0009;color:#dfefff;border:1px solid #2b3a44;border-radius:10px;z-index:25;opacity:.85;transition:opacity .7s ease}
  .hide{display:none !important}
  .overlay-text{position:fixed;inset:0;display:grid;place-items:center;pointer-events:none;font-family:"Press Start 2P",monospace;font-size:10vw;color:#39ff14;text-shadow:0 0 12px #39ff14,0 0 22px #39ff14;opacity:.15}
  @media (max-width: 860px){
    .hud{gap:8px}
    .hud input,.hud button,.hud select{padding:7px 9px}
    #legend{top:92px}
  }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com"><link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>

<!-- HUD -->
<div class="hud" id="hud">
  <div class="row">
    <label for="heightInput">Height:</label>
    <input id="heightInput" type="number" min="1" style="width:140px"/>
    <button id="loadBtn" class="btn">Load</button>
    <button id="latestBtn" class="btn">Latest</button>
    <button id="resetBtn" class="btn">Reset View</button>
  </div>
  <div class="row" style="margin-left:auto">
    <label>Protons</label>
    <select id="selProton">
      <option>Auto</option><option>Marble</option><option>Lava</option>
      <option>Glass</option><option>Wireframe</option><option>Spikes</option><option>Clouds</option>
    </select>
    <label>Neutrons</label>
    <select id="selNeutron">
      <option>Auto</option><option>Marble</option><option>Lava</option>
      <option>Glass</option><option>Wireframe</option><option>Spikes</option><option>Clouds</option>
    </select>
    <label>Electrons</label>
    <select id="selElectron">
      <option>Auto</option><option>Marble</option><option>Lava</option>
      <option>Glass</option><option>Wireframe</option><option>Spikes</option><option>Clouds</option>
    </select>
  </div>
</div>

<!-- Controls legend -->
<div class="panel" id="legend">
  <b>Controls</b>
  <div>• Rotate/Tilt: drag / 1-finger</div>
  <div>• Pan: right-drag / 2-finger drag</div>
  <div>• Zoom: wheel / pinch</div>
  <div style="opacity:.8;margin-top:4px">Tip: press <b>E</b> (desktop) or <b>double-tap</b> (mobile) to toggle UI</div>
</div>

<!-- Info -->
<details id="infoPanel" class="panel" open>
  <summary><span class="badge">?</span> Info / How it works</summary>
  <div id="how" style="margin-top:6px;opacity:.9"></div>
</details>

<!-- Block details -->
<details id="blockPanel" class="panel" open>
  <summary><span class="badge">#</span> Block Details</summary>
  <div id="blkBody" style="margin-top:6px"></div>
</details>

<!-- Halving background pulse (drawn by p5, but we'll show pixel "1337" here when needed) -->
<div id="overlay1337" class="overlay-text hide">1337</div>

<!-- Quick hint that fades after 15s -->
<div id="hint" class="toast">Press <b>E</b> or <b>double-tap</b> to toggle UI</div>

<script src="https://unpkg.com/p5@1.9.2/lib/p5.min.js"></script>
<script>
/* ============================================================
   Utils
   ============================================================ */
const $ = s => document.querySelector(s);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const mod=(a,n)=>((a%n)+n)%n;
function XS32(seed){let x=seed>>>0||1;return()=>{x^=x<<13;x^=x>>>17;x^=x<<5;return (x>>>0)/0xFFFFFFFF;};}
const shortHash=h=>h?(String(h).slice(0,10)+'…'+String(h).slice(-8)):'n/a';
const API='https://mempool.space/api';
async function fetchText(u){const r=await fetch(u); if(!r.ok) throw new Error(r.status+' '+u); return (await r.text()).trim();}
async function fetchJSON(u){const r=await fetch(u); if(!r.ok) throw new Error(r.status+' '+u); return r.json();}

/* ============================================================
   Camera
   ============================================================ */
const cam = { theta:0, phi:0.25, dist:900, tx:0, ty:0, tz:0, spin:0.6*Math.PI/180, minDist:30, maxDist:20000 };
const defaults = JSON.parse(JSON.stringify(cam));
let isPointerDown=false, isPanning=false, isPinching=false, idle=true, uiVisible=true;
let lastX=0,lastY=0, baseDist=cam.dist, pinchBase=1;
let multiTouch = new Map();

function setUIVisible(v){ uiVisible=v; const d=v?'':'none'; ['hud','legend','infoPanel','blockPanel'].forEach(id=>{const n=$('#'+id); if(n) n.style.display=d;}); }
function toggleUI(){ setUIVisible(!uiVisible); }
let lastTapTime=0; function handleTapToggle(){ const now=performance.now(); if(now-lastTapTime<320){toggleUI(); lastTapTime=0;} else lastTapTime=now; }
function resetView(){ Object.assign(cam, defaults); idle=true; }

function toCam(){ const c=Math.cos(cam.theta), s=Math.sin(cam.theta), cp=Math.cos(cam.phi), sp=Math.sin(cam.phi);
  const fx=c*cp, fy=sp, fz=s*cp; const eye=[cam.tx+fx*cam.dist, cam.ty+fy*cam.dist, cam.tz+fz*cam.dist]; const up=[-c*sp,cp,-s*sp];
  return {eye,center:[cam.tx,cam.ty,cam.tz],up};
}
function applyPan(dx,dy){
  const c=Math.cos(cam.theta), s=Math.sin(cam.theta), cp=Math.cos(cam.phi), sp=Math.sin(cam.phi);
  const rx=-s, ry=0, rz=c;         // right
  const ux=-c*sp, uy=cp, uz=-s*sp; // up
  const k=cam.dist*0.0015;
  cam.tx += (-dx*rx + dy*ux)*k;
  cam.ty += (-dx*ry + dy*uy)*k;
  cam.tz += (-dx*rz + dy*uz)*k;
}

/* ============================================================
   Styles and shader
   ============================================================ */
const STYLE = { MARBLE:1, LAVA:2, GLASS:3, WIREFRAME:4, SPIKES:5, CLOUDS:6 };

const VERT = `
precision mediump float;
attribute vec3 aPosition;
attribute vec3 aNormal;
uniform mat4 uProjectionMatrix, uModelViewMatrix, uNormalMatrix;
uniform float uTime;
uniform int uStyle;
uniform float uSpikeAmp;   // for SPIKES (actual geo displacement)
varying vec3 vPos;
varying vec3 vNormal;
varying vec3 vView;
varying float vNoise;

float hash(vec3 p){ return fract(sin(dot(p,vec3(12.9898,78.233,37.719)))*43758.5453); }
float n3(vec3 p){
  vec3 i=floor(p), f=fract(p);
  float n000=hash(i+vec3(0,0,0)), n100=hash(i+vec3(1,0,0));
  float n010=hash(i+vec3(0,1,0)), n110=hash(i+vec3(1,1,0));
  float n001=hash(i+vec3(0,0,1)), n101=hash(i+vec3(1,0,1));
  float n011=hash(i+vec3(0,1,1)), n111=hash(i+vec3(1,1,1));
  vec3 u=f*f*(3.0-2.0*f);
  float n00=mix(n000,n100,u.x), n10=mix(n010,n110,u.x);
  float n01=mix(n001,n101,u.x), n11=mix(n011,n111,u.x);
  float n0=mix(n00,n10,u.y), n1=mix(n01,n11,u.y);
  return mix(n0,n1,u.z);
}

void main(){
  vec3 pos = aPosition;
  vec3 N = normalize(aNormal);
  // real displacement for SPIKES
  float k = 0.0;
  if(uStyle==5){ // SPIKES
    float t = uTime*0.5;
    float d = n3(N*6.0 + t*vec3(0.7,0.9,1.3));
    k = (d-0.5)*2.0 * uSpikeAmp; // centered around 0
    pos += N * k;
  }
  vec4 mv = uModelViewMatrix * vec4(pos,1.0);
  vPos = mv.xyz;
  vNormal = mat3(uNormalMatrix) * normalize(aNormal + N*0.001);
  vView = normalize(-mv.xyz);
  vNoise = k;
  gl_Position = uProjectionMatrix * mv;
}
`;

const FRAG = `
precision mediump float;
varying vec3 vPos;
varying vec3 vNormal;
varying vec3 vView;
varying float vNoise;

uniform float uTime;
uniform int uStyle;
uniform vec3 uColorA;
uniform vec3 uColorB;
uniform float uAnim1;
uniform float uAnim2;
uniform float uRnd;   // per-orb random seed

// small helpers
float hash(vec3 p){ return fract(sin(dot(p,vec3(12.9898,78.233,37.719)))*43758.5453); }
float n3(vec3 p){
  vec3 i=floor(p), f=fract(p);
  float n000=hash(i+vec3(0,0,0)), n100=hash(i+vec3(1,0,0));
  float n010=hash(i+vec3(0,1,0)), n110=hash(i+vec3(1,1,0));
  float n001=hash(i+vec3(0,0,1)), n101=hash(i+vec3(1,0,1));
  float n011=hash(i+vec3(0,1,1)), n111=hash(i+vec3(1,1,1));
  vec3 u=f*f*(3.0-2.0*f);
  float n00=mix(n000,n100,u.x), n10=mix(n010,n110,u.x);
  float n01=mix(n001,n101,u.x), n11=mix(n011,n111,u.x);
  float n0=mix(n00,n10,u.y), n1=mix(n01,n11,u.y);
  return mix(n0,n1,u.z);
}
vec3 tone(vec3 c){ return pow(c, vec3(0.92)); }
float fresnel(vec3 n, vec3 v){ return pow(1.0 - max(dot(n,v), 0.0), 3.0); }

void main(){
  vec3 N = normalize(vNormal);
  vec3 V = normalize(vView);
  vec3 L1 = normalize(vec3(0.6,0.8,0.5));
  vec3 L2 = normalize(vec3(-0.5,0.7,-0.2));
  float ndl = max(dot(N,L1),0.0)*0.6 + max(dot(N,L2),0.0)*0.4;

  vec3 col = vec3(0.7);
  float alpha = 1.0;

  if(uStyle==1){ // MARBLE
    vec3 P = normalize(vPos)*2.0;
    float t = uTime*0.35 + uRnd*10.0;
    float m = sin(P.x*5.1 + 1.7*n3(P.yzx*2.2 + t) + t) * 0.5 + 0.5;
    m = smoothstep(0.25,0.75,m);
    vec3 base = mix(uColorA, uColorB, m);
    float spec = pow(max(dot(N, normalize(L1+V)),0.0), 80.0)*0.7 + pow(max(dot(N, normalize(L2+V)),0.0), 60.0)*0.5;
    col = tone(base*(0.25+0.75*ndl) + vec3(spec));
  }
  else if(uStyle==2){ // LAVA
    vec3 P = normalize(vPos)*3.5 + uRnd*3.0;
    float t = uTime*(0.6+uRnd*0.8);
    float a = n3(P + vec3(0.0,t,0.0)) * 0.7 + 0.3*n3(P*2.7 - vec3(t,0.0,t));
    vec3 base = mix(uColorA, uColorB, smoothstep(0.3,0.8,a));
    float inc = smoothstep(0.75,0.9,a);
    vec3 hot = base + vec3(inc*0.6, inc*0.25, 0.0);
    float spec = pow(max(dot(N, normalize(L1+V)),0.0), 25.0);
    col = tone(hot*(0.18+0.82*ndl) + vec3(spec*0.6));
  }
  else if(uStyle==3){ // GLASS bubble (thin-film + ripples)
    float t = uTime*0.25;
    // ripple: bend normal with traveling waves
    vec3 P = normalize(vPos);
    float w = sin((P.x+P.y+P.z)*18.0 + t*2.8) + 0.5*sin(P.y*28.0 - t*1.7 + uRnd*6.2831);
    w *= (1.0 + 4.0*uAnim1);          // amplitude slider (we drive from uAnim1)
    vec3 Nb = normalize(N + P*0.08*w); // bend normal
    float fr = fresnel(Nb, V);
    // thin-film hue sweep in view angle
    float hue = fract(fr*0.85 + uRnd*0.37 + uTime*0.03);
    // quick HSV-ish rainbow
    vec3 a = vec3(abs(hue*6.0-3.0)-1.0, 2.0-abs(hue*6.0-2.0), 2.0-abs(hue*6.0-4.0));
    vec3 irid = clamp(a, 0.0, 1.0);
    vec3 base = mix(vec3(0.92,0.98,1.0), irid, 0.55); // mostly clear with sheen
    float highlight = pow(max(dot(Nb, normalize(L1+V)),0.0), 70.0)*0.9;
    float body = 0.08 + 0.15*ndl;     // very transparent body
    col = tone(base*body + highlight);
    alpha = 0.35 + 0.45*fr;           // transparent, edge-bright
  }
  else if(uStyle==4){ // WIREFRAME (neon grid)
    vec3 P = normalize(vPos)*3.0;
    // approximate spherical UV
    float u = atan(P.z, P.x)/6.2831 + 0.5;
    float v = acos(clamp(P.y, -1.0, 1.0))/3.14159;
    float lineU = smoothstep(0.48,0.5,abs(fract(u*24.0)-0.5));
    float lineV = smoothstep(0.48,0.5,abs(fract(v*24.0)-0.5));
    float grid = clamp(1.0 - min(lineU, lineV), 0.0, 1.0);
    vec3 neon = mix(uColorA, vec3(0.95,1.0,0.95), 0.35);
    col = neon * (0.15 + 0.85*grid);
    alpha = 0.25 + 0.65*grid;
  }
  else if(uStyle==5){ // SPIKES (shaded like metallic)
    float spec = pow(max(dot(N, normalize(L1+V)),0.0), 90.0)*0.9 + pow(max(dot(N, normalize(L2+V)),0.0), 60.0)*0.6;
    vec3 base = mix(uColorA, uColorB, 0.45 + 0.35*sin(vNoise*12.0 + uTime*2.0));
    col = tone(base*(0.25+0.75*ndl) + vec3(spec));
  }
  else if(uStyle==6){ // CLOUDS sky
    vec3 P = normalize(vPos)*2.8;
    float t = uTime*0.25 + uRnd*5.0;
    float f = n3(P + vec3(t,0.0,-t))*0.6 + 0.4*n3(P*1.7 - vec3(0.0,t,t));
    vec3 sky = mix(uColorA, uColorB, 0.85);
    vec3 cloud = mix(vec3(1.0), sky, 0.25);
    vec3 mixc = mix(sky, cloud, smoothstep(0.45,0.7,f));
    float spec = pow(max(dot(N, normalize(L1+V)),0.0), 40.0)*0.35;
    col = tone(mixc*(0.22+0.78*ndl) + vec3(spec));
  }
  else{ // SAFE fallback
    col = vec3(0.7)*(0.25+0.75*ndl);
  }

  gl_FragColor = vec4(clamp(col,0.0,1.0), clamp(alpha,0.0,1.0));
}
`;

/* ============================================================
   Atom generation & block mapping
   ============================================================ */
const TWO_PI = Math.PI*2;
const NUCLEON_R = 5, ELECTRON_R = 4;
const SHELL_STEP = 85, NUCLEUS_R0 = 60;

function autoPickStyle(hByte){
  switch(hByte % 6){ // deterministic variety
    case 0: return STYLE.MARBLE;
    case 1: return STYLE.LAVA;
    case 2: return STYLE.GLASS;
    case 3: return STYLE.WIREFRAME;
    case 4: return STYLE.SPIKES;
    case 5: return STYLE.CLOUDS;
  }
  return STYLE.MARBLE;
}
function styleFromUI(selVal, hByte){
  if(!selVal || selVal==='Auto') return autoPickStyle(hByte);
  const m = {Marble:STYLE.MARBLE, Lava:STYLE.LAVA, Glass:STYLE.GLASS, Wireframe:STYLE.WIREFRAME, Spikes:STYLE.SPIKES, Clouds:STYLE.CLOUDS};
  return m[selVal] || autoPickStyle(hByte);
}
function isHalving(height){ return height>0 && (height%210000)===0; }

function makeAtomFromBlock(blk){
  const height=blk.height|0, hash=(blk.id||blk.hash||'');
  const rndByte = (i)=> (parseInt((hash.replace(/[^0-9a-f]/ig,'').substr(i*2,2) || '7f'),16) || 127);
  const rseed = rndByte(3) ^ (rndByte(7)<<8) ^ (rndByte(11)<<16) ^ (height<<1);
  const rand = XS32(rseed);

  // counts
  const electrons = 32 + (rndByte(1)%40);
  const shells=[]; let rem=electrons, n=1; while(rem>0&&shells.length<7){ const cap=2*n*n; const take=Math.min(rem,cap); shells.push(take); rem-=take; n++; }
  const radii=shells.map((_,i)=>NUCLEUS_R0+SHELL_STEP*(i+1));
  const nucleus=[]; const totalN=70+(rndByte(9)%60);
  for(let i=0;i<totalN;i++){
    const r = NUCLEUS_R0*0.45 * Math.pow(rand(), 0.55);
    const th = rand()*TWO_PI, ph = Math.acos(2*rand()-1);
    nucleus.push([r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph), i < totalN/2]); // isProton flag 0/1
  }

  // colors (base palette varies by height)
  const hue = (height*0.61803398875)%1;
  function hsl(h,s,l){ // returns [0..1]
    let r,g,b; const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};
    const q=l<0.5?l*(1+s):l+s-l*s, p=2*l-q;
    r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3); return [r,g,b];
  }
  const protonColA = hsl(hue,0.75,0.55), protonColB = hsl((hue+0.05)%1,0.6,0.45);
  const neutronColA= hsl((hue+0.25)%1,0.65,0.58), neutronColB=hsl((hue+0.33)%1,0.55,0.42);
  const electronColA= hsl((hue+0.6)%1,0.85,0.62), electronColB=hsl((hue+0.68)%1,0.75,0.48);

  // style selection (per set; UI overrides if present)
  const pStyle = styleFromUI($('#selProton')?.value, rndByte(2));
  const nStyle = styleFromUI($('#selNeutron')?.value, rndByte(5));
  const eStyle = styleFromUI($('#selElectron')?.value, rndByte(8));

  // special cases
  const disco170 = height===170;
  const leet1337 = height===1337;
  const halving = isHalving(height) && !disco170 && !leet1337;

  return {
    height, hash, electrons, shells, radii, nucleus,
    colors:{protonA:protonColA, protonB:protonColB, neutronA:neutronColA, neutronB:neutronColB, electronA:electronColA, electronB:electronColB},
    style:{pStyle,nStyle,eStyle, disco170, leet1337, halving}
  };
}

/* ============================================================
   p5 Scene
   ============================================================ */
let p5i=null, orbShader=null, shaderOK=true, atom=null;

function startSketch(){
  if(p5i) p5i.remove();
  p5i = new p5((p)=>{
    p.setup = function(){
      p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
      p.setAttributes('antialias', true);
      p.perspective(p.PI/3, p.width/p.height, 0.1, 30000);
      orbShader = p.createShader(VERT, FRAG);
      try{
        // force link now (p5 links lazily)
        p.shader(orbShader); p.resetShader();
      }catch(e){ console.warn('Shader not linked, using fallback', e); shaderOK=false; }
      attachCanvasEvents(p);
    };
    p.windowResized = ()=>p.resizeCanvas(p.windowWidth, p.windowHeight);

    function setMaterial(style, cA, cB, rseed, anim1, anim2, spikeAmp){
      if(!shaderOK){ p.ambientMaterial(cA[0]*255, cA[1]*255, cA[2]*255, 230); return; }
      p.shader(orbShader);
      orbShader.setUniform('uTime', p.millis()*0.001);
      orbShader.setUniform('uStyle', style|0);
      orbShader.setUniform('uColorA', cA);
      orbShader.setUniform('uColorB', cB);
      orbShader.setUniform('uAnim1', anim1||0.0);
      orbShader.setUniform('uAnim2', anim2||0.0);
      orbShader.setUniform('uRnd', rseed);
      orbShader.setUniform('uSpikeAmp', spikeAmp||0.0);
    }
    function drawSphere(style, r, cA, cB, rseed, spikeAmp){
      setMaterial(style, cA, cB, rseed, 1.0, 0.0, spikeAmp);
      p.noStroke();
      p.sphere(r, 36, 24);
      p.resetShader();
    }

    function hueRgb(h){ // quick rainbow (0..1)
      const a = [Math.abs(h*6.0-3.0)-1.0, 2.0-Math.abs(h*6.0-2.0), 2.0-Math.abs(h*6.0-4.0)];
      return [Math.max(0,Math.min(1,a[0])), Math.max(0,Math.min(1,a[1])), Math.max(0,Math.min(1,a[2]))];
    }

    p.draw = function(){
      // background (halving pulse)
      if(atom?.style.halving){
        const t = p.millis()*0.001;
        const k = (Math.sin(t*2.5)*0.5+0.5);
        p.background( clamp(20+ k*190, 0, 255), clamp(10+k*110,0,255), 0 );
      } else {
        p.background(0);
      }

      // camera
      const {eye,center,up}=toCam();
      p.camera(eye[0],eye[1],eye[2], center[0],center[1],center[2], up[0],up[1],up[2]);
      if (idle && !isPointerDown && !isPanning && !isPinching){
        cam.theta += cam.spin; // coin-like constant vertical-axis spin
      }

      if(!atom){ return; }

      // lighting baseline
      p.ambientLight(24);
      p.directionalLight(200,200,200, 0.7,0.8,0.6);
      p.directionalLight(160,160,220, -0.6,0.5,-0.3);

      // special overlays
      $('#overlay1337').classList.toggle('hide', !atom.style.leet1337);

      // rings
      p.push(); p.noFill();
      if(atom.style.disco170){
        const t=p.millis()*0.001; const steps=160;
        for(let i=0;i<atom.shells.length;i++){
          const r=atom.radii[i];
          p.beginShape();
          for(let k=0;k<=steps;k++){
            const ang=(k/steps)*TWO_PI;
            const hue = (t*0.25 + (k/steps) + i*0.08);
            const cc=hueRgb(hue%1).map(v=>v*255);
            p.stroke(cc[0],cc[1],cc[2],220); p.strokeWeight(2);
            p.vertex(r*Math.cos(ang), r*Math.sin(ang), 0);
          }
          p.endShape();
        }
      } else if(atom.style.halving){
        const t=p.millis()*0.001, pulse=1.0+0.15*Math.sin(t*3.0);
        p.stroke(255,200,40, 220); p.strokeWeight(2.5*pulse);
        for(let i=0;i<atom.shells.length;i++){
          const r=atom.radii[i];
          p.beginShape(); for(let a=0;a<=180;a++){ const ang=a/180*TWO_PI; p.vertex(Math.cos(ang)*r, Math.sin(ang)*r, 0); } p.endShape();
        }
      } else if(atom.style.leet1337){
        p.stroke(40,255,80,230); p.strokeWeight(2);
        for(let i=0;i<atom.shells.length;i++){
          const r=atom.radii[i];
          p.beginShape(); for(let a=0;a<=180;a++){ const ang=a/180*TWO_PI; p.vertex(Math.cos(ang)*r, Math.sin(ang)*r, 0); } p.endShape();
        }
      } else {
        p.stroke(255,140,140,190); p.strokeWeight(2);
        for(let i=0;i<atom.shells.length;i++){
          const r=atom.radii[i];
          p.beginShape(); for(let a=0;a<=180;a++){ const ang=a/180*TWO_PI; p.vertex(Math.cos(ang)*r, Math.sin(ang)*r, 0); } p.endShape();
        }
      }
      p.pop();

      // nucleus (protons vs neutrons styles)
      p.push();
      const pStyle = atom.style.leet1337 ? STYLE.WIREFRAME : atom.style.disco170 ? STYLE.MARBLE : atom.style.pStyle;
      const nStyle = atom.style.leet1337 ? STYLE.WIREFRAME : atom.style.disco170 ? STYLE.MARBLE : atom.style.nStyle;

      for(const q of atom.nucleus){
        p.push(); p.translate(q[0],q[1],q[2]);
        const isP = q[3];
        let cA = (isP? atom.colors.protonA : atom.colors.neutronA);
        let cB = (isP? atom.colors.protonB : atom.colors.neutronB);
        let style = isP? pStyle : nStyle;
        let spikesAmp = (style===STYLE.SPIKES)? 0.65 : 0.0; // strong spikes
        if(atom.style.leet1337){
          // override colors for 1337 wireframes
          if(isP) { cA=[1.0,0.95,0.2]; cB=cA; }        // neon yellow
          else    { cA=[1.0,0.45,0.05]; cB=cA; }       // neon orange
        }
        if(atom.style.disco170){
          const t=p.millis()*0.001; const hue=(t*0.15 + (isP?0.0:0.2))%1; cA=hueRgb(hue); cB=hueRgb((hue+0.12)%1);
        }
        drawSphere(style, NUCLEON_R, cA, cB, Math.random(), spikesAmp);
        p.pop();
      }

      // halving nucleus soft glow (additive)
      if(atom.style.halving){
        p.push(); p.blendMode(p.ADD); p.noStroke();
        p.fill(255,200,40, 28);
        p.sphere(NUCLEUS_R0*1.6, 24, 16);
        p.fill(255,210,80, 18); p.sphere(NUCLEUS_R0*2.2, 16, 12);
        p.blendMode(p.BLEND); p.pop();
      }
      p.pop();

      // electrons (orbital motion)
      const eStyle = atom.style.leet1337 ? STYLE.WIREFRAME : atom.style.disco170 ? STYLE.MARBLE : atom.style.eStyle;
      let eClrA = atom.colors.electronA, eClrB = atom.colors.electronB;
      if(atom.style.leet1337){ eClrA=[0.20,1.0,0.35]; eClrB=eClrA; }
      for(let i=0;i<atom.shells.length;i++){
        const r=atom.radii[i], k=atom.shells[i];
        for(let j=0;j<k;j++){
          const a=(j/k)*TWO_PI + (p.frameCount*0.01 + i*0.25);
          const x=Math.cos(a)*r, y=Math.sin(a)*r, z=Math.sin(a*1.3 + i*0.7)*40;
          p.push(); p.translate(x,y,z);
          let cA=eClrA, cB=eClrB, spikesAmp=(eStyle===STYLE.SPIKES)?0.55:0.0;
          if(atom.style.disco170){ const t=p.millis()*0.001; const hue=(t*0.15 + j*0.01 + i*0.05)%1; cA=hueRgb(hue); cB=hueRgb((hue+0.12)%1); }
          drawSphere(eStyle, ELECTRON_R, cA, cB, (i*37+j*101)%1000/1000, spikesAmp);
          p.pop();
        }
      }
    };
  });
}

/* ============================================================
   Canvas / input events
   ============================================================ */
function attachCanvasEvents(p){
  const c = p._renderer?.canvas; if(!c) return;
  c.style.touchAction='none';

  c.addEventListener('wheel',(e)=>{ e.preventDefault(); idle=false; const factor=Math.exp(-e.deltaY*0.0014); cam.dist=clamp(cam.dist*factor,cam.minDist,cam.maxDist); }, {passive:false});

  c.addEventListener('pointerdown',(e)=>{
    c.setPointerCapture(e.pointerId);
    multiTouch.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(multiTouch.size===1){ isPointerDown=true; isPanning=(e.button===2); lastX=e.clientX; lastY=e.clientY; }
    else if(multiTouch.size===2){
      isPinching=true; isPanning=true; isPointerDown=false;
      const pts=[...multiTouch.values()]; pinchBase=dist2(pts[0],pts[1]); baseDist=cam.dist; lastX=(pts[0].x+pts[1].x)/2; lastY=(pts[0].y+pts[1].y)/2;
    }
    idle=false;
    if(e.pointerType==='touch') handleTapToggle();
  });
  c.addEventListener('pointermove',(e)=>{
    if(!multiTouch.has(e.pointerId)) return;
    multiTouch.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(isPinching && multiTouch.size>=2){
      const pts=[...multiTouch.values()];
      const cx=(pts[0].x+pts[1].x)/2, cy=(pts[0].y+pts[1].y)/2;
      const d=dist2(pts[0],pts[1]); const scale=clamp(d/Math.max(1,pinchBase),0.25,4.0);
      cam.dist=clamp(baseDist/scale,cam.minDist,cam.maxDist);
      const dx=cx-lastX, dy=cy-lastY; applyPan(dx,dy); lastX=cx; lastY=cy;
    } else if(isPointerDown){
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      if(isPanning){ applyPan(dx,dy); }
      else{ cam.theta -= dx*0.0050; cam.phi = clamp(cam.phi - dy*0.0030, -Math.PI/2+0.05, Math.PI/2-0.05); }
      lastX=e.clientX; lastY=e.clientY;
    }
  });
  c.addEventListener('pointerup',(e)=>{ multiTouch.delete(e.pointerId); if(multiTouch.size===0){isPointerDown=false;isPanning=false;isPinching=false;idle=true;} if(multiTouch.size===1){const [o]=multiTouch.values(); lastX=o.x; lastY=o.y; isPinching=false;} });
  c.addEventListener('pointercancel',()=>{ multiTouch.clear(); isPointerDown=false; isPanning=false; isPinching=false; idle=true; });
  c.addEventListener('contextmenu', e=>e.preventDefault());
}
function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

/* ============================================================
   HUD, loading, and panels
   ============================================================ */
function renderBlockPanels(atom, blk){
  const how = `
    <p><b>Mapping</b></p>
    <ul>
      <li>Palette varies by <code>height</code> (golden-hue offset).</li>
      <li>Counts and distributions seeded by <code>block hash</code> bytes.</li>
      <li>Style per set (protons / neutrons / electrons) is deterministic; you can override in the HUD.</li>
      <li>Special cases:
        <ul>
          <li><b>Halving</b>: pulsing orange→black background, gold pulsing rings, soft nucleus glow.</li>
          <li><b>#170</b>: ROYGBIV rings + color-cycling orbs (disco mode).</li>
          <li><b>#1337</b>: neon wireframes (green electrons, yellow protons, orange neutrons) + big pixel “1337”.</li>
        </ul>
      </li>
    </ul>`;
  $('#how').innerHTML = how;

  const styleName=(s)=>({1:'Marble',2:'Lava',3:'Glass',4:'Wireframe',5:'Spikes',6:'Clouds'}[s]||'Safe');
  const body = $('#blkBody');
  body.innerHTML = '';
  const chips=document.createElement('div');
  [['Electrons',atom.electrons],['Shells',atom.shells.length],
   ['Protons',atom.nucleus.filter(q=>q[3]).length],['Neutrons',atom.nucleus.filter(q=>!q[3]).length]].forEach(([k,v])=>{
    const sp=document.createElement('span'); sp.className='chip'; sp.textContent=`${k}: ${v}`; chips.appendChild(sp);
  });
  if(atom.style.disco170){ const sp=document.createElement('span'); sp.className='chip'; sp.textContent='🎉 Disco 170'; chips.appendChild(sp); }
  if(atom.style.halving){ const sp=document.createElement('span'); sp.className='chip'; sp.textContent='Halving Mode'; chips.appendChild(sp); }
  if(atom.style.leet1337){ const sp=document.createElement('span'); sp.className='chip'; sp.textContent='1337 Mode'; chips.appendChild(sp); }
  body.appendChild(chips);

  const table=document.createElement('table'); table.style.marginTop='6px'; table.style.width='100%'; table.style.lineHeight='1.45';
  const rows=[
    ['Height', blk.height], ['Hash', shortHash(blk.id||blk.hash)], ['Tx count', blk.tx_count??'n/a'],
    ['Size (bytes)', blk.size??'n/a'], ['Weight (WU)', blk.weight??'n/a'], ['Version', blk.version??'n/a'],
    ['Bits', blk.bits??'n/a'], ['Nonce', blk.nonce??'n/a'], ['Time', blk.timestamp?new Date(blk.timestamp*1000).toLocaleString():'n/a'],
    ['Styles (sets)', `p=${styleName(atom.style.pStyle)} n=${styleName(atom.style.nStyle)} e=${styleName(atom.style.eStyle)}`]
  ];
  rows.forEach(([k,v])=>{
    const tr=document.createElement('tr');
    const td1=document.createElement('td'); td1.textContent=k; td1.style.opacity='.8'; td1.style.padding='2px 4px'; td1.style.width='36%';
    const td2=document.createElement('td'); td2.textContent=String(v); td2.style.padding='2px 4px';
    tr.appendChild(td1); tr.appendChild(td2); table.appendChild(tr);
  });
  body.appendChild(table);
}

async function loadBlockByHeight(h){
  const hash=await fetchText(API+'/block-height/'+h);
  const blk=await fetchJSON(API+'/block/'+hash);
  atom = makeAtomFromBlock(blk);
  renderBlockPanels(atom, blk);
  resetView();
}
async function loadLatest(){
  const h=await fetchText(API+'/blocks/tip/height');
  $('#heightInput').value=h;
  await loadBlockByHeight(h);
}

/* ============================================================
   Wiring
   ============================================================ */
$('#resetBtn').onclick = ()=> resetView();
$('#loadBtn').onclick  = async()=>{ const h=Number($('#heightInput').value||0); if(!h){alert('Enter a block height'); return;} await loadBlockByHeight(h); };
$('#latestBtn').onclick= async()=>{ await loadLatest(); };
['selProton','selNeutron','selElectron'].forEach(id=>{
  $('#'+id).addEventListener('change', ()=>{ if(atom){ // rebuild atom with same blk mapping but new overrides
    const blk = currentBlkHeader; if(blk){ atom = makeAtomFromBlock(blk); } }});
});

window.addEventListener('keydown',(e)=>{ if(e.key.toLowerCase()==='e') toggleUI(); });

/* Keep last header so style overrides can rebuild from it */
let currentBlkHeader=null;
async function loadAndRemember(h){
  const hash=await fetchText(API+'/block-height/'+h);
  const blk=await fetchJSON(API+'/block/'+hash);
  currentBlkHeader=blk;
  atom = makeAtomFromBlock(blk);
  renderBlockPanels(atom, blk);
  resetView();
}

/* Boot */
startSketch();
$('#heightInput').value = '0'; // will be replaced by latest
// Fade hint
setTimeout(()=>{ const h=$('#hint'); if(h) h.style.opacity=0; setTimeout(()=>h.remove(), 800); }, 15000);

// Auto-load latest on start
loadLatest().then(()=>{ /* remember header too */ }).catch(console.warn);
// new26
</script>
</body>
</html>
